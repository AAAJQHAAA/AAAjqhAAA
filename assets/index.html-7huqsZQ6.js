import{_ as s,c as l,a,o as e}from"./app-CiQOVv9k.js";const n={};function t(d,i){return e(),l("div",null,i[0]||(i[0]=[a(`<ul><li><p>原码：最高位为符号位，0-正数；1-负数；</p></li><li><p>反码：正数反码是本身，负数反码除符号全部按位取反；</p></li><li><p>补码：正数补码是本身，负数补码是反码+1；</p></li><li><p>按位运算：</p><ul><li>&amp;（与）：全1是1</li><li>|（或）：有1是1</li><li>^（异或）：相异为1</li><li>~（按位取反）</li></ul></li><li><p>java中变量都是以补码的形式保存的</p></li><li><p>cpu计算器只有加法没有减法， 减法用正数和负数相加得到</p></li><li><p>java中移位运算（int是4个字节32位）（移&gt;32，移位n%32位）</p></li></ul><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>&lt;&lt;(左移)：低位补0,相当于乘以2；（符号位不变）</span></span>
<span class="line"><span>&gt;&gt;(带符号右移)：正数高位补0，负数高位补1；</span></span>
<span class="line"><span>&gt;&gt;&gt;（无符号右移）：高位补0，相当于除以2；（负数是补码移动）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>计算机硬件有两种储存数据的方式：大端字节序和小端字节序</p><ul><li>大端字节序：高位字节在前，低位字节在后</li><li>小端字节序：低位字节在前，高位字节在后</li><li>计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。</li></ul><h1 id="java集合" tabindex="-1"><a class="header-anchor" href="#java集合"><span>java集合</span></a></h1><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map"><span>Map</span></a></h2><ul><li><code>HashMap</code>(线程不安全) <ul><li>哈希映射</li><li>数组+链表 <ul><li>根据key的hash值%数组容量(capacity)，找到数组中的一个位置（一个位置可能有多个元素）</li><li>每个位置存放链表</li></ul></li><li>无序，k/v可为null，key不可以重复</li><li>链表（jdk1.8） <ul><li>链化：当链表长度小于等于6时，红黑树将转化为链表，（此时链表查询速度比红黑树快）</li><li>树化：当链表长度大于8时，数组容量大于等于64时，将链表转化为红黑树（平衡二叉树），（此时红黑树查询速度比链表快）</li></ul></li><li>数组扩容：当元素size个数超过临界值时（临界值=容量capacity*负载因子loadFactor），扩容后的容量capacity是之前两倍，resize()会将元素重新put进新的数组中 <ul><li>扩容会消耗性能，所以预设元素的个数能够有效的提高hashmap的性能</li></ul></li><li>常用方法： <ul><li>查询方法：<code>size()</code>、<code>isEmpty()</code>、<code>get(Object)</code>、<code>containsKey(Object)</code></li><li>修改方法：<code>put(k,v)</code>、<code>remove(Object)</code></li><li>批量操作：<code>keySet()</code>、<code>clear()</code></li></ul></li><li><code>LinkedHashMap</code>(线程不安全) <ul><li>链式哈希映射</li><li>和hashMap的区别： <ul><li>每个元素使用双向链表（记录上一个节点和下一个节点）</li><li>记录头节点和尾节点</li><li>有序</li><li>构造方法可以设置是添加顺序（默认）、还是访问顺序 <ul><li>添加顺序（默认）：添加谁，尾节点就指向谁</li><li>访问顺序（构造方法设置）：获取谁，尾节点就指向谁，头节点指向它下一个</li></ul></li></ul></li></ul></li></ul></li><li>ConcurrentHashMap(线程安全) <ul><li>key、value都不能为null</li></ul></li><li>TreeMap(线程不安全) <ul><li>二叉树映射（红黑树） <ul><li>红黑树条件：每个节点非黑即红、根节点是黑色、叶节点是黑色、每个红节点下的子节点是黑色、任意节点到叶节点的每条路径上的黑色节点树相同</li></ul></li><li>无序</li><li>k不能为null（null不能比较）</li><li>key唯一</li><li>常用方法： <ul><li>查询操作：<code>size()</code>、<code>isEmpty()</code>、<code>get(object)</code>、<code>containsKey(Object)</code></li><li>修改操作：<code>put(k,v)</code>、<code>remove(Object)</code></li><li>批量操作：<code>keySet()</code>、<code>clear()</code>、<code>descendingMap()</code></li></ul></li></ul></li></ul><h2 id="collection" tabindex="-1"><a class="header-anchor" href="#collection"><span>Collection</span></a></h2><ul><li>方法分类 <ul><li>修改操作：<code>boolean add(E)</code>、<code>boolean remove(Object)</code></li><li>查询操作：<code>size()</code>、<code>isEmpty()</code>、<code>contains(Object)</code>、<code>iterator()</code>、<code>toArray()</code>、<code>toArray(T[])</code></li><li>批量操作：<code>containAll(Collection&lt;?&gt;)</code>、<code>addAll(Collection&lt;?&gt;)</code>、<code>boolean removeAll(Collection&lt;?&gt;)</code>、<code>boolean removeIf(Predicate&lt;?&gt;)</code><ul><li><code>boolean retainAll(Collection&lt;?&gt;)</code>、<code>clear()</code>、<code>spliterator()</code>、<code>stream()</code>、<code>parallelStream()</code></li></ul></li></ul></li><li>List <ul><li><code>ArrayList</code>(线程不安全) <ul><li>数组存储数据</li><li>可重复、可null</li><li>查询快：索引查询</li><li>增删慢：数组满了之后会扩容1.5倍，然后再拷贝数据到新数组 <ul><li>无参构造初始容量10</li></ul></li><li>常用方法： <ul><li>查询方法：<code>get(int)</code>、<code>indexOf(Object)</code>、<code>iterator()</code>、<code>size()</code>、<code>isEmpty()</code></li><li>修改方法：<code>add(E)</code>、<code>set(int,E)</code>、<code>remove(int)</code></li><li>批量操作：<code>clear()</code>、<code>stream()</code></li></ul></li></ul></li><li>CopyOnWriteArrayList(线程安全)</li><li><code>LinkedList</code>(线程不安全) <ul><li>双向链表</li><li>有序、可重复、可为null</li><li>增删快：增加删除只需要调整前后节点</li><li>查询慢：知道索引也只能从头部或者尾部遍历找到对应的目标</li><li>常用方法： <ul><li>查询方法：<code>getFirst()</code>、<code>getLast()</code>、<code>size()</code>、<code>isEmpty()</code></li><li>修改操作：<code>add(E)</code>、<code>addFirst(E)</code></li><li>批量操作：<code>listIterator()</code>、<code>clear()</code>、<code>stream()</code></li></ul></li></ul></li></ul></li><li>Set <ul><li><code>HashSet</code>(线程不安全) <ul><li>哈希集合（HashMap存储数据）</li><li>无序、值唯一、值可为null</li><li>常用方法： <ul><li>查询操作：<code>size()</code>、<code>isEmpty()</code>、<code>contains(Object)</code></li><li>修改操作：<code>add(E)</code>、<code>remove(Object)</code></li><li>批量操作：<code>iterator()</code>、<code>clear()</code></li></ul></li><li><code>LinkedHashSet</code>(线程不安全) <ul><li>链式哈希集合（LinkedHashMap存储数据）</li><li>和hashset区别：有序</li></ul></li></ul></li><li><code>CopyOnWriteArraySet</code>(线程安全)</li><li><code>TreeSet</code>(线程不安全) <ul><li>二叉树集合（TreeMap实现）</li><li>无序、值不为null、值唯一</li><li>常用方法： <ul><li>查询操作：<code>size()</code>、<code>isEmpty()</code>、<code>contains(Object)</code></li><li>修改操作：<code>add(E)</code>、<code>remove(Object)</code></li><li>批量操作：<code>iterator()</code>、<code>clear()</code>、<code>descendingIterator()</code></li></ul></li></ul></li></ul></li></ul><h1 id="java面向对象编程" tabindex="-1"><a class="header-anchor" href="#java面向对象编程"><span>java面向对象编程</span></a></h1><h2 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h2><ul><li>使得子类对象（实例）具有父类的实例域和方法</li><li>关键字 <ul><li><code>extends</code>，单一继承类，不支持多继承</li><li><code>implements</code>，实现接口</li><li><code>super</code>来实现对父类成员的访问 <ul><li>不显式调用，父类无参构造方法会隐式调用</li><li>父类有参构造方法需要super显式调用</li></ul></li><li><code>this</code>指向自己的引用</li><li><code>final</code>用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类 <ul><li>修饰的类不能被继承</li><li>修饰的方法不能被重写</li></ul></li></ul></li><li>重写(Override)：子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变</li><li>重载(Overload)：在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同</li></ul><h2 id="多态" tabindex="-1"><a class="header-anchor" href="#多态"><span>多态</span></a></h2><ul><li>多态就是同一个接口，使用不同的实例而执行不同操作</li><li>父类引用指向子类对象</li><li>实现方式 <ul><li>继承+重写</li><li>接口</li></ul></li></ul><h2 id="封装" tabindex="-1"><a class="header-anchor" href="#封装"><span>封装</span></a></h2><ul><li>将抽象性函式接口的实现细节部分包装、隐藏起来的方法</li><li>例如：类中属性变量设置为<code>private</code>私有的，提供get/set方法访问和设置变量。</li></ul><h1 id="java8新特性" tabindex="-1"><a class="header-anchor" href="#java8新特性"><span>java8新特性</span></a></h1><h2 id="lambda-表达式" tabindex="-1"><a class="header-anchor" href="#lambda-表达式"><span>Lambda 表达式</span></a></h2><ul><li>使用条件：必须有接口（不能是抽象类），接口中有且仅有一个需要被重写的抽象方法</li><li>省略规则： <ul><li><code>()</code>中的<code>参数类型</code>可以省略</li><li>如果<code>()</code>中只有<code>一个参数</code>，那么可以省略<code>()</code></li><li>如果<code>{}</code>中只有<code>一条语句</code>，那么可以省略<code>{}</code>、<code>return</code>、<code>;</code></li></ul></li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>(参数类型 参数名) -&gt; {</span></span>
<span class="line"><span>    方法体;</span></span>
<span class="line"><span>    return 返回值;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="方法引用" tabindex="-1"><a class="header-anchor" href="#方法引用"><span>方法引用<code>::</code></span></a></h2><h2 id="新增了接口的默认方法default" tabindex="-1"><a class="header-anchor" href="#新增了接口的默认方法default"><span>新增了接口的默认方法<code>default</code></span></a></h2><h2 id="stream" tabindex="-1"><a class="header-anchor" href="#stream"><span>Stream</span></a></h2><ul><li>Stream（流）是一个来自<code>数据源</code>的<code>元素队列</code>并支持<code>聚合操作</code><ul><li>数据源<code>Collection</code>、<code>Arrays</code></li></ul></li><li>常用方法 <ul><li>中间操作(返回流) <ul><li><code>limit()</code>获取指定数量元素的流</li><li><code>sorted()</code>返回排序后的流</li><li><code>filter()</code>过滤流，返回符合条件的流</li><li><code>distinct()</code>去除重复元素</li><li><code>map()</code>返回处理后的流</li></ul></li><li>终止操作 <ul><li><code>forEach()</code>遍历流中元素</li><li><code>count()</code>返回流中元素个数</li><li><code>findFirst()</code>返回流中第一个元素</li><li><code>toArray()</code>将流中的元素转换为数组</li><li><code>collect(Collector&lt;? super T, A, R&gt; collector)</code>将流中的元素收集到另一个目标中 <ul><li><code>List&lt;String&gt; result = stream.collect(Collections.tolist());</code>收集到List</li><li><code>Set&lt;String&gt; result = stream.collect(Collections.toSet());</code>收集到Set</li><li><code>TreeSet&lt;String&gt; result = stream.collect(Collectors.toCollection(Treeset::new));</code>收集到Treeset</li><li><code>String result = stream.collect(Collectors.joining());</code>收集一个字符串</li></ul></li></ul></li></ul></li></ul><h2 id="optional类" tabindex="-1"><a class="header-anchor" href="#optional类"><span>Optional类</span></a></h2><ul><li>创建 <ul><li><code>Optional.of(T)</code>不为空的Optional</li><li><code>Optional.ofNullable(T)</code>可以为空的Optional</li><li><code>Optional.empty()</code>值为null的Optional</li></ul></li><li>方法 <ul><li><code>isPresent()</code>对象持有的值是否不为null</li><li><code>get()</code>获取内部持有的值，内部值为null时会抛出异常</li><li><code>ifPresent(Consumer&lt;? super T&gt;)</code>在值存在的情况下,以值为参数,调用Consumer</li><li><code>filter(Predicate&lt;? super T&gt;)</code>值不存在则直接返回this(empty)；值存在判断值是否满足Predicate，满足返回this，不满足返回empty</li><li><code>map(Function&lt;? super T, ? extends U&gt;)</code>在内部值不为null的情况下, 通过传入的Function, 将内部值处理成新的值, 并构造成新的Optional对象返回.</li><li><code>orElse(T)</code>如果值为null, 则返回该方法的参数值.</li><li><code>orElseGet(Supplier&lt;? extends T&gt;)</code>如果内部值为空, 就返回supplier提供的值</li><li><code>orElseThrow(Supplier&lt;? extends X&gt;)</code>如果为空就抛出supplier提供的异常</li></ul></li></ul><h1 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式"><span>单例模式</span></a></h1><ul><li>懒汉式与饿汉式的根本区别在与是否在类内方法外创建自己的对象。</li></ul><h1 id="题目" tabindex="-1"><a class="header-anchor" href="#题目"><span>题目</span></a></h1><h2 id="_1、如下代码1和2两处运行分别时什么结果" tabindex="-1"><a class="header-anchor" href="#_1、如下代码1和2两处运行分别时什么结果"><span>1、如下代码1和2两处运行分别时什么结果？</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> test1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        List</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ArrayList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">aaa</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">bbb</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">ccc</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">ddd</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        /*</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         * remove(int index)</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         * 每删除一个元素，数组都会发生一次复制，将后面元素复制到前面，</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         * 通过索引删除，删除不全</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         * */</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">size</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">remove</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> s</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> :</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">====</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 1</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        /*</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         * remove(Object o)</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         * 遍历过程中修改，会抛异常</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         * */</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> s</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> :</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">remove</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> s</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> :</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">====</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 2</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2、设计模式中的设计原则是什么" tabindex="-1"><a class="header-anchor" href="#_2、设计模式中的设计原则是什么"><span>2、设计模式中的设计原则是什么？</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>1、开闭原则（Open Close Principle）</span></span>
<span class="line"><span>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</span></span>
<span class="line"><span>2、里氏代换原则（Liskov Substitution Principle）</span></span>
<span class="line"><span>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</span></span>
<span class="line"><span>3、依赖倒转原则（Dependence Inversion Principle）</span></span>
<span class="line"><span>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</span></span>
<span class="line"><span>4、接口隔离原则（Interface Segregation Principle）</span></span>
<span class="line"><span>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</span></span>
<span class="line"><span>5、迪米特法则，又称最少知道原则（Demeter Principle）</span></span>
<span class="line"><span>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</span></span>
<span class="line"><span>6、合成复用原则（Composite Reuse Principle）</span></span>
<span class="line"><span>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3、数组的增和删一定比链表的效率低吗-原因是" tabindex="-1"><a class="header-anchor" href="#_3、数组的增和删一定比链表的效率低吗-原因是"><span>3、数组的增和删一定比链表的效率低吗？原因是？</span></a></h2><p>因为CPU缓存会读入一段连续的内存，顺序存储符合连续的内存，所以顺序存储可以被缓存处理，而链接存储并不是连续的，分散在堆中，所以只能内存去处理。 所以数组查询比链表要快。 而数组大小固定，插入和删除都需要移动元素，链表可以动态扩充，插入删除不需要移动元素，只需要更改元素中的指针。所以链表的插入删除比数组效率高。</p><h2 id="_4、hashmap、hashtable、concurrenthashmap的异同点" tabindex="-1"><a class="header-anchor" href="#_4、hashmap、hashtable、concurrenthashmap的异同点"><span>4、hashMap、hashTable、concurrentHashMap的异同点？</span></a></h2><p>hashMap：key/value都可为null、线程不安全 hashTable：key/value都不可为null、线程安全（锁整个数组） concurrentHashMap：key/value都可为null、线程安全（分段锁）</p><h1 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识"><span>基础知识</span></a></h1><h3 id="spring-cloud-配置文件优先级" tabindex="-1"><a class="header-anchor" href="#spring-cloud-配置文件优先级"><span>Spring cloud 配置文件优先级</span></a></h3><ul><li><code>classpath:/bootstrap.yml</code></li><li><code>./bootstrap.yml</code></li><li><code>./config/bootstrap.yml</code></li><li><code>classpath:/application.yml</code></li><li><code>./application.yml</code></li><li><code>./config/application.yml</code></li><li><code>springconfig中心/config/application.yml</code></li><li><code>springconfig中心/config/spring.application.name.yml</code></li><li><code>springconfig中心/config/spring.application.name-dev.yml</code></li></ul>`,40)]))}const h=s(n,[["render",t],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/article/u5u97d64/","title":"java中的位运算","lang":"zh-CN","frontmatter":{"title":"java中的位运算","createTime":"2023/11/09 15:03:28","tags":["java.util类","java国际化"],"permalink":"/article/u5u97d64/"},"headers":[],"readingTime":{"minutes":10.1,"words":3029},"git":{"updatedTime":1737255104000,"contributors":[{"name":"jqh","username":"jqh","email":"1789622669@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/e51d6bd9179d8251507631920dbee86805db2675024268e3d9894ba170e9c314?d=retro"}]},"filePathRelative":"2024/后端/java/java.md","categoryList":[{"id":"07811d","sort":10001,"name":"2024"},{"id":"6b006b","sort":10003,"name":"后端"},{"id":"eaa43d","sort":10004,"name":"java"}],"bulletin":false}');export{h as comp,c as data};
