{"meta":{"title":"JQH","subtitle":"博客笔记","description":"前后端等相关笔记","author":"jqh","url":"https://aaajqhaaa.github.io"},"pages":[{"title":"404","date":"2023-11-02T03:13:25.000Z","updated":"2024-01-18T00:35:49.290Z","comments":true,"path":"404/index.html","permalink":"https://aaajqhaaa.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-11-01T07:29:48.000Z","updated":"2024-01-18T00:35:49.337Z","comments":true,"path":"categories/index.html","permalink":"https://aaajqhaaa.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-11-01T08:24:06.000Z","updated":"2024-01-18T00:35:49.338Z","comments":true,"path":"tags/index.html","permalink":"https://aaajqhaaa.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"IFrame","slug":"前端/html/IFrame","date":"2024-02-05T07:46:45.000Z","updated":"2024-02-18T03:23:01.854Z","comments":true,"path":"2024/02/05/前端/html/IFrame/","link":"","permalink":"https://aaajqhaaa.github.io/2024/02/05/%E5%89%8D%E7%AB%AF/html/IFrame/","excerpt":"","text":"HTMLIFrameElement12345678910111213141516171819202122232425262728293031323334353637383940// 提供特殊的属性和方法(除了HTMLElement接口之外，它还可以通过继承获得这些属性和方法)，用于操作内联框架元素的布局和表示。interface HTMLIFrameElement extends HTMLElement &#123; /** * 设置或检索对象与相邻文本的对齐方式。 */ /** @弃用 */ align: string; allow: string; allowFullscreen: boolean; allowPaymentRequest: boolean; readonly contentDocument: Document | null;// 检索页或框架的文档对象 readonly contentWindow: WindowProxy | null;// window对象 /** @弃用 */ frameBorder: string;// 设置或检索是否为框架显示边框 height: string;// 高度 /** @弃用 */ longDesc: string;// 为对象的长描述设置或检索URI /** @弃用 */ marginHeight: string;// 设置或检索在框架中显示文本之前的上下边距高度 /** @弃用 */ marginWidth: string;// 设置或检索在框架中显示文本之前的左右边距宽度 name: string;// 名称 referrerPolicy: ReferrerPolicy; readonly sandbox: DOMTokenList; /** @弃用 */ scrolling: string;// 是否可以滚动 src: string;// 加载的URL。 srcdoc: string;// 包含的页的内容 width: string;// 对象的宽度 getSVGDocument(): Document | null;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html标签","slug":"html标签","permalink":"https://aaajqhaaa.github.io/tags/html%E6%A0%87%E7%AD%BE/"},{"name":"IFrame","slug":"IFrame","permalink":"https://aaajqhaaa.github.io/tags/IFrame/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"loader加载器","slug":"前端/webpack/loader","date":"2024-02-04T07:20:21.000Z","updated":"2024-02-04T07:27:41.156Z","comments":true,"path":"2024/02/04/前端/webpack/loader/","link":"","permalink":"https://aaajqhaaa.github.io/2024/02/04/%E5%89%8D%E7%AB%AF/webpack/loader/","excerpt":"","text":"html-loader 将HTML文件导出为字符串。当编译器需要时，将压缩HTML字符串 安装：npm install --save-dev html-loader 配置：12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.html$/i, loader: &#x27;html-loader&#x27;, &#125;, ], &#125;,&#125;; 使用：import html from &#39;./file.html&#39;;","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://aaajqhaaa.github.io/tags/webpack/"},{"name":"loader","slug":"loader","permalink":"https://aaajqhaaa.github.io/tags/loader/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"vscode","slug":"其他/vscode","date":"2024-02-04T06:26:52.000Z","updated":"2024-02-05T02:33:18.952Z","comments":true,"path":"2024/02/04/其他/vscode/","link":"","permalink":"https://aaajqhaaa.github.io/2024/02/04/%E5%85%B6%E4%BB%96/vscode/","excerpt":"","text":"vscode快捷键 格式化代码：shift + alt + f 行代码上下移动：alt + 上/下 行代码想下复制：shift+ alt + 下","categories":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"vscode快捷键","slug":"vscode快捷键","permalink":"https://aaajqhaaa.github.io/tags/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"vue脚手架element-ui按需引入","slug":"前端/vue/element","date":"2024-02-04T06:10:33.000Z","updated":"2024-02-04T06:16:05.923Z","comments":true,"path":"2024/02/04/前端/vue/element/","link":"","permalink":"https://aaajqhaaa.github.io/2024/02/04/%E5%89%8D%E7%AB%AF/vue/element/","excerpt":"","text":"vue脚手架element-ui按需引入 官网教程：https://element.eleme.cn/#/zh-CN/component/quickstart 安装： npm i element-ui -S npm install babel-plugin-component -D 脚手架中babel.config.js配置文件123456789101112module.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27; ], plugins: [ [&#x27;component&#x27;, &#123; libraryName: &#x27;element-ui&#x27;, //插件的名字 style: true, styleLibraryName: &#x27;theme-chalk&#x27; //css样式存放目录 &#125;, &#x27;element-ui&#x27;] ]&#125; 按需引入element-ui-components.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164import Vue from &#x27;vue&#x27;;import &#123; Pagination, Dialog, Autocomplete, Dropdown, DropdownMenu, DropdownItem, Menu, Submenu, MenuItem, MenuItemGroup, Input, InputNumber, Radio, RadioGroup, RadioButton, Checkbox, CheckboxButton, CheckboxGroup, Switch, Select, Option, OptionGroup, Button, ButtonGroup, Table, TableColumn, DatePicker, TimeSelect, TimePicker, Popover, Tooltip, Breadcrumb, BreadcrumbItem, Form, FormItem, Tabs, TabPane, Tag, Tree, Alert, Slider, Icon, Row, Col, Upload, Progress, Spinner, Badge, Card, Rate, Steps, Step, Carousel, CarouselItem, Collapse, CollapseItem, Cascader, ColorPicker, Transfer, Container, Header, Aside, Main, Footer, Timeline, TimelineItem, Link, Divider, Image, Calendar, Backtop, PageHeader, CascaderPanel, Loading, MessageBox, Message, Notification&#125; from &#x27;element-ui&#x27;;Vue.use(Pagination);Vue.use(Dialog);Vue.use(Autocomplete);Vue.use(Dropdown);Vue.use(DropdownMenu);Vue.use(DropdownItem);Vue.use(Menu);Vue.use(Submenu);Vue.use(MenuItem);Vue.use(MenuItemGroup);Vue.use(Input);Vue.use(InputNumber);Vue.use(Radio);Vue.use(RadioGroup);Vue.use(RadioButton);Vue.use(Checkbox);Vue.use(CheckboxButton);Vue.use(CheckboxGroup);Vue.use(Switch);Vue.use(Select);Vue.use(Option);Vue.use(OptionGroup);Vue.use(Button);Vue.use(ButtonGroup);Vue.use(Table);Vue.use(TableColumn);Vue.use(DatePicker);Vue.use(TimeSelect);Vue.use(TimePicker);Vue.use(Popover);Vue.use(Tooltip);Vue.use(Breadcrumb);Vue.use(BreadcrumbItem);Vue.use(Form);Vue.use(FormItem);Vue.use(Tabs);Vue.use(TabPane);Vue.use(Tag);Vue.use(Tree);Vue.use(Alert);Vue.use(Slider);Vue.use(Icon);Vue.use(Row);Vue.use(Col);Vue.use(Upload);Vue.use(Progress);Vue.use(Spinner);Vue.use(Badge);Vue.use(Card);Vue.use(Rate);Vue.use(Steps);Vue.use(Step);Vue.use(Carousel);Vue.use(CarouselItem);Vue.use(Collapse);Vue.use(CollapseItem);Vue.use(Cascader);Vue.use(ColorPicker);Vue.use(Transfer);Vue.use(Container);Vue.use(Header);Vue.use(Aside);Vue.use(Main);Vue.use(Footer);Vue.use(Timeline);Vue.use(TimelineItem);Vue.use(Link);Vue.use(Divider);Vue.use(Image);Vue.use(Calendar);Vue.use(Backtop);Vue.use(PageHeader);Vue.use(CascaderPanel);Vue.use(Loading.directive);Vue.prototype.$loading = Loading.service;Vue.prototype.$msgbox = MessageBox;Vue.prototype.$alert = MessageBox.alert;Vue.prototype.$confirm = MessageBox.confirm;Vue.prototype.$prompt = MessageBox.prompt;Vue.prototype.$notify = Notification;Vue.prototype.$message = Message; 脚手架中main.js引入element-ui-components.js1import element-ui-components.js","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://aaajqhaaa.github.io/tags/vue/"},{"name":"element-ui","slug":"element-ui","permalink":"https://aaajqhaaa.github.io/tags/element-ui/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"canvasApi","slug":"前端/canvas/canvasApi","date":"2024-02-01T03:07:24.000Z","updated":"2024-02-18T03:23:01.859Z","comments":true,"path":"2024/02/01/前端/canvas/canvasApi/","link":"","permalink":"https://aaajqhaaa.github.io/2024/02/01/%E5%89%8D%E7%AB%AF/canvas/canvasApi/","excerpt":"","text":"canvas APIHTMLCanvasElement12345678910111213141516171819202122/** 提供用于操作&lt;canvas&gt;元素的布局和表示的属性和方法。HTMLCanvasElement接口也继承了HTMLElement接口的属性和方法。 */class HTMLCanvasElement extends HTMLElement &#123; height: number;// 画布元素的高度。 width: number;// 画布元素的宽度。 /** * 返回一个对象，该对象提供用于在文档中的画布元素上绘制和操作图像和图形的方法和属性。上下文对象包括有关颜色、线宽、字体和其他可以在画布上绘制的图形参数的信息。 * @param contextId 要创建的画布类型的标识符(ID)。IE 9和IE 10只支持2d上下文;IE11支持使用canvas.getContext(&quot;experimental-webgl&quot;)的3d或WebGL上下文; */ getContext(contextId: &quot;2d&quot;, options?: CanvasRenderingContext2DSettings): CanvasRenderingContext2D | null; getContext(contextId: &quot;bitmaprenderer&quot;, options?: ImageBitmapRenderingContextSettings): ImageBitmapRenderingContext | null; getContext(contextId: &quot;webgl&quot;, options?: WebGLContextAttributes): WebGLRenderingContext | null; getContext(contextId: &quot;webgl2&quot;, options?: WebGLContextAttributes): WebGL2RenderingContext | null; getContext(contextId: string, options?: any): RenderingContext | null; // 画布中包含的图像 toBlob(callback: BlobCallback, type?: string, quality?: any): void; // 将当前画布的内容作为图像返回，您可以将该图像用作另一个画布或HTML元素的源。 toDataURL(type?: string, quality?: any): string; // 对画布内容的实时视频捕获 captureStream(frameRate?: number): CanvasCaptureMediaStream; // 将控制权转移到主线程或工作线程上 transferControlToOffscreen(): OffscreenCanvas;&#125; CanvasRenderingContext2D123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163class CanvasRenderingContext2D &#123; canvas: HTMLCanvasElement;// canvas只读引用 width: number;// 画布元素的高度。 height: number;// 画布元素的宽度。 // 对于没有直接固定到特定画布的上下文 commit(): void; // 状态 // 保存 当前状态 到堆栈上 save(): void; // 弹出 图形状态堆栈中的 顶部条目 restore(): void; // 转换 currentTransform: SVGMatrix;// 当前的变换 // （坐标系）缩放 水平或垂直 scale(x: number, y: number): void; // （坐标系）旋转（弧度 = 角度 * Math.PI / 180） rotate(angle: number): void; // （坐标系）移动 translate(x: number, y: number): void; // （坐标系）矩阵变换：缩放(a,d)、旋转(b,c)、平移(e,f)（相对变换矩阵，在当前基础上变换） transform(a: number, b: number, c: number, d: number, e: number, f: number): void; // （坐标系）矩阵变换：缩放(a,d)、旋转(b,c)、平移(e,f)（绝对变换矩阵，取消当前变换设置成新的变换） setTransform(a: number, b: number, c: number, d: number, e: number, f: number): void; // 重新设置 resetTransform(): void; // 合成 globalAlpha: number;// 设置图形和图片透明度(0.0-1.0) globalCompositeOperation: string;// 设置绘制新形状时应用的合成操作的类型 // 图像的平滑 imageSmoothingEnabled: boolean;// 设置图片是否平滑 imageSmoothingQuality: &#x27;low&#x27; | &#x27;medium&#x27; | &#x27;high&#x27;;// 设置图像平滑度的属性 // 过滤器 filter: string;// 提供模糊、灰度等过滤效果的属性 // 颜色和款式 strokeStyle: string | CanvasGradient | CanvasPattern;// 设置上下文颜色(描边) fillStyle: string | CanvasGradient | CanvasPattern;// 设置上下文颜色(填充) // 两点之间构建线性渐变，返回值赋值给 fillStyle 或者 strokeStyle createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient; // 两圆之间构建放射性渐变 createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient; // 图像背景（填充），返回值赋值给 fillStyle createPattern(image: CanvasImageSource, repetition: ?string): CanvasPattern; // 指定点周围创建渐变（开始弧度，坐标x，坐标y） createConicGradient(startAngle, x, y): CanvasGradient; // 阴影 shadowOffsetX: number;// 阴影水平偏移距离 shadowOffsetY: number;// 阴影垂直偏移距离 shadowBlur: number;// 模糊效果程度 shadowColor: string;// 阴影颜色 // 矩形 // 清除区域(x坐标，y坐标，宽，高)【透明】 clearRect(x: number, y: number, w: number, h: number): void; // 绘制填充矩形(x坐标，y坐标，宽，高) fillRect(x: number, y: number, w: number, h: number): void; // 绘制描边矩形(x坐标，y坐标，宽，高) strokeRect(x: number, y: number, w: number, h: number): void; // 路径API // 清空之前子路径，开始新的路径绘制 beginPath(): void; // （填充）根据当前的填充样式，填充当前或已存在的路径。采取非零环绕或者奇偶环绕规则 fill(fillRule?: CanvasFillRule): void; fill(path: Path2D, fillRule?: CanvasFillRule): void; // （描边）使用非零环绕规则，根据当前的画线样式，绘制当前或已经存在的路径 stroke(): void; stroke(path: Path2D): void; // 用来给当前路径或特定路径绘制焦点的方法，如果给定的元素获取了焦点。 drawFocusIfNeeded(element: Element): void; drawFocusIfNeeded(path: Path2D, element: Element): void; // 将当前或给定的路径滚动到窗口的方法 scrollPathIntoView(): void; scrollPathIntoView(path: Path2D): void; // 路径裁剪（裁剪出有效区域，浏览器会将后面所有的绘图操作都限制在本区域内执行） clip(fillRule?: CanvasFillRule): void; clip(path: Path2D, fillRule?: CanvasFillRule): void; resetClip(): void; // 用于判断在当前路径中是否包含检测点的方法 isPointInPath(x: number, y: number, fillRule?: CanvasFillRule): boolean; isPointInPath(path: Path2D, x: number, y: number, fillRule?: CanvasFillRule): boolean; // 用于检测某点是否在路径的描边线上的方法 isPointInStroke(x: number, y: number): boolean; isPointInStroke(path: Path2D, x: number, y: number): boolean; // 文本(参见CanvasDrawingStyles接口) // （填充）在指定的坐标上绘制文本 fillText(text: string, x: number, y: number, maxWidth?: number): void; // （描边）在给定的 (x, y) 位置绘制文本 strokeText(text: string, x: number, y: number, maxWidth?: number): void; // 被测量文本信息 measureText(text: string): TextMetrics; // 画图片 // 绘图+移动 drawImage(image: CanvasImageSource, dx: number, dy: number): void; // 绘图+移动+缩放（dx,dy,dw,dh视图） drawImage(image: CanvasImageSource, dx: number, dy: number, dw: number, dh: number): void; // 绘图+裁剪+移动+缩放（sx,sy,sw,sh相机视口、dx,dy,dw,dh视图） drawImage(image: CanvasImageSource, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void; // 点击区域 addHitRegion(options?: HitRegionOptions): void; removeHitRegion(id: string): void; clearHitRegions(): void; // 像素操作 // 创建一个新的、空白的、指定大小的 ImageData 对象。所有的像素在新对象中都是透明的 createImageData(sw: number, sh: number): ImageData; createImageData(imagedata: ImageData): ImageData; // 获取描述 canvas 区域隐含的像素数据 getImageData(sx: number, sy: number, sw: number, sh: number): ImageData; putImageData(imagedata: ImageData, dx: number, dy: number): void; putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void; // 画布绘画风格 lineWidth: number;// 设置线段厚度（描边） lineCap: string;// 线段端点样式（描边） lineJoin: string;// 线段拐角样式（描边） miterLimit: number;// 拐角最大厚度（描边） // 虚线 // 描边设置为虚线（[实、虚、实、虚....]） setLineDash(segments: Array&lt;number&gt;): void; // 获取当前线段样式的方法 getLineDash(): Array&lt;number&gt;; lineDashOffset: number;// 设置虚线偏移量（前面） // 文本 font: string;// 当前字体样式 textAlign: string;// 文本的对齐方式 textBaseline: string;// 当前文本基线 direction: string;// 当前文本方向 // 路径方法 // 共享路径API方法 // 将笔点连到当前子路径起始点的方法 closePath(): void; // 将一个新的子路径的起始点移动到 (x，y) 坐标 moveTo(x: number, y: number): void; // 使用直线连接子路径的终点到 x，y 坐标 lineTo(x: number, y: number): void; // 新增二次贝塞尔曲线路径（控制点x,控制点y,端点x,端点y） quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void; // 绘制三次贝赛尔曲线路径（控制点x,控制点y,控制点x2,控制点y2,端点x,端点y） bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void; // 根据控制点和半径绘制圆弧路径，使用当前的描点 (前一个 moveTo 或 lineTo 等函数的止点)（控制点x,控制点y,控制点x2,控制点y2,弧度） arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void; arcTo(x1: number, y1: number, x2: number, y2: number, radiusX: number, radiusY: number, rotation: number): void; // 创建矩形路径的方法，矩形的起点位置是 (x, y)，尺寸为 width 和 height。矩形的 4 个点通过直线连接，子路径做为闭合的标记，所以你可以填充或者描边矩形 rect(x: number, y: number, w: number, h: number): void; // 绘制圆弧路径(x,y,半径,开始弧度,结束弧度,是否逆时针方向) arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void; // 添加椭圆路径的方法 ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;&#125; Path2D CanvasPath1234567891011interface CanvasPath &#123; arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void; arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void; bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void; closePath(): void; ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void; lineTo(x: number, y: number): void; moveTo(x: number, y: number): void; quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void; rect(x: number, y: number, w: number, h: number): void;&#125; 123456interface Path2D extends CanvasPath &#123; /** * Adds to the path the path given by the argument. */ addPath(path: Path2D, transform?: DOMMatrix2DInit): void;&#125; ImageBitmapRenderingContextWebGLRenderingContextWebGL2RenderingContext","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://aaajqhaaa.github.io/tags/canvas/"},{"name":"canvas API","slug":"canvas-API","permalink":"https://aaajqhaaa.github.io/tags/canvas-API/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"canvas","slug":"前端/canvas/canvas","date":"2024-01-31T08:58:10.000Z","updated":"2024-02-19T05:56:12.752Z","comments":true,"path":"2024/01/31/前端/canvas/canvas/","link":"","permalink":"https://aaajqhaaa.github.io/2024/01/31/%E5%89%8D%E7%AB%AF/canvas/canvas/","excerpt":"","text":"canvas API简介 API教程：https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API Canvas API提供了一个通过JS和HTML的&lt;canvas&gt;元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。 https://www.cnblogs.com/fangsmile/category/849399.html?page=3 Canvas教程 https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial canvas坐标原点在左上角：向右是x轴正方向，向下是y轴正方向 学习的话主要是看API和例子 直接画填充矩形、画填充文本、描边矩形、描边文本 画矩形路径，画圆路径，然后填充or描边 上下文状态保存、重置 坐标系矩阵变换之后，后面的操作是针对该坐标系 demo：https://techbrood.com/?q=canvas demo：https://codepen.io/search/pens?q=canvas Canvas深入 https://joshondesign.com/p/books/canvasdeepdive/toc.html 数学基础 向量，矩阵运算 https://www.leapreal.com/posts/db6f6769.html 第三方库 EaselJS 使制作游戏、创作类艺术和其他侧重图形项目更容易的开源 canvas 库 Fabric.js 具有 SVG 解析功能的开源 canvas 库 heatmap.js 基于 canvas 的热点图的开源库 JavaScript InfoVis Toolkit 创建交互式的 2D Canvas 数据可视化 Konva.js 用于桌面端和移动端应用的 2D canvas 库 p5.js 包含给艺术家、设计师、教育者、初学者使用的完整的 canvas 绘制功能 Paper.js 运行于 HTML5 Canvas 上的开源矢量图形脚本框架 Phaser 用于基于 Canvas 和 WebGL 的浏览器尤其的快速、自由、有趣的开源框架 Processing.js 用于处理可视化语言 Pts.js 在 canvas 和 SVG 中进行创意性代码写作和可视化的库 Rekapi 关键帧动画库 Scrawl-canvas 用来创建和编辑 2D 图形的开源库 ZIM 框架为 canvas 上的代码创意性提供方便性、组件和可控性，包括可用性和数百个色彩缤纷的教程","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://aaajqhaaa.github.io/tags/canvas/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"webgl","slug":"前端/webgl/webgl","date":"2024-01-17T11:07:56.000Z","updated":"2024-01-18T00:35:49.330Z","comments":true,"path":"2024/01/17/前端/webgl/webgl/","link":"","permalink":"https://aaajqhaaa.github.io/2024/01/17/%E5%89%8D%E7%AB%AF/webgl/webgl/","excerpt":"","text":"webgl https://juejin.cn/column/7067063198054105118 https://github.com/buglas/webgl-lesson","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"webgl","slug":"webgl","permalink":"https://aaajqhaaa.github.io/tags/webgl/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Pannellum实现全景图编辑&预览","slug":"前端/threejs/Pannellum","date":"2024-01-17T01:03:03.000Z","updated":"2024-01-17T11:00:04.775Z","comments":true,"path":"2024/01/17/前端/threejs/Pannellum/","link":"","permalink":"https://aaajqhaaa.github.io/2024/01/17/%E5%89%8D%E7%AB%AF/threejs/Pannellum/","excerpt":"","text":"Pannellum实现全景图编辑&amp;预览 全景图片展示，需要支持热点 目标做一个全景图编辑界面，修改配置，绘制热点等功能，绘制完成之后，可以生成链接访问 介绍 github：https://github.com/mpetroff/pannellum.git 教程网站：https://pannellum.org/ Pannellum是一个轻量级、免费和开源的Web全景查看器。它使用HTML5、CSS3、JavaScript和WebGL构建，无需插件。 依赖下载123456&lt;!-- 最新编译和缩小的独立查看器 --&gt;https://cdn.pannellum.org/2.5/pannellum.htm&lt;!-- 最新编译和缩小的JavaScript --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js&quot;&gt;&lt;/script&gt;&lt;!-- 最新编译和缩小的CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css&quot;&gt; 全景图格式为equirectangular等距柱状投影，可以直接使用pannellum.htm访问打开 https://cdn.pannellum.org/2.5/pannellum.htm#panorama=https://pannellum.org/images/alma.jpg pannellum.htm访问打开也可以把配置写在json文件里面（config指定文件地址） https://cdn.pannellum.org/2.5/pannellum.htm#config=https://pannellum.org/configs/compass.json JSON配置选项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&#123; &quot;type&quot;:&quot;【String】【选填】指定全景类型，cubemap、multires、equirectangular（默认）&quot;, &quot;title&quot;:&quot;【String】【选填】全景图的标题&quot;, &quot;author&quot;:&quot;【String】【选填】全景图的作者&quot;, &quot;authorURL&quot;:&quot;【String】【选填】全景图的作者URL，点击名字跳转&quot;, &quot;strings&quot;:&quot;【词典】【选填】不知道啥用&quot;, &quot;autoLoad&quot;:&quot;【Boolean】【选填】自动加载，默认false&quot;, &quot;autoRotate&quot;:&quot;【int】【选填】加载成功后自动旋转速度，正为逆时针、负为顺时针&quot;, &quot;autoRotateInactivityDelay&quot;:&quot;【int】【选填】用户活动停止后自动旋转速度，正为逆时针、负为顺时针【前提：autoRotate】&quot;, &quot;autoRotateStopDelay&quot;:&quot;【int】【选填】设置延迟多少毫秒后停止自动旋转【前提：autoRotate】&quot;, &quot;fallback&quot;:&quot;【String】【选填】用户设备或者链接不工作时，替换方案的URL&quot;, &quot;orientationOnByDefault&quot;:&quot;【Boolean】【选填】默认开启设备方向控制&quot;, &quot;showZoomCtrl&quot;:&quot;【Boolean】【选填】显示缩放控件&quot;, &quot;keyboardZoom&quot;:&quot;【Boolean】【选填】使用键盘缩放&quot;, &quot;mouseZoom&quot;:&quot;【Boolean、String】【选填】使用鼠标滚轮进行缩放false、true、fullscreenonly（只有全屏时支持）&quot;, &quot;draggable&quot;:&quot;【Boolean】【选填】禁用鼠标和触摸拖动&quot;, &quot;friction&quot;:&quot;【number,0-1之间】【选填】惯性摩擦力，默认0.15&quot;, &quot;disableKeyboardCtrl&quot;:&quot;【Boolean】【选填】禁用键盘控件&quot;, &quot;showFullscreenCtrl&quot;:&quot;【Boolean】【选填】显示全屏控件&quot;, &quot;showControls&quot;:&quot;【Boolean】【选填】显示控件&quot;, &quot;touchPanSpeedCoeffFactor&quot;:&quot;【int】【选填】调整触摸输入的平移速度,默认1&quot;, &quot;yaw&quot;:&quot;【int】【选填】全景图的起始偏航位置（以度为单位）,默认0&quot;, &quot;pitch&quot;:&quot;【int】【选填】全景图的起始俯仰位置（以度为单位）,默认0&quot;, &quot;hfov&quot;:&quot;【int】【选填】全景图的起始水平视野（以度为单位）,默认100&quot;, &quot;minYaw&quot;:&quot;【int】【选填】全景图的最小偏航（以度为单位）,默认-180&quot;, &quot;maxYaw&quot;:&quot;【int】【选填】全景图的最大偏航（以度为单位）,默认180&quot;, &quot;minPitch&quot;:&quot;【int】【选填】全景图的最小间距（以度为单位）,默认-90&quot;, &quot;maxPitch&quot;:&quot;【int】【选填】全景图的最大间距（以度为单位）,默认90&quot;, &quot;minHfov&quot;:&quot;【int】【选填】全景图的最小水平视野（以度为单位）,默认50&quot;, &quot;maxHfov&quot;:&quot;【int】【选填】全景图的最大水平视野（以度为单位）,默认120&quot;, &quot;multiResMinHfov&quot;:&quot;【Boolean】【选填】自动计算的最小水平视野&quot;, &quot;compass&quot;:&quot;【Boolean】【选填】显示指南针&quot;, &quot;northOffset&quot;:&quot;【int】【选填】全景图中心与北的偏移量【前提：compass】&quot;, &quot;preview&quot;:&quot;【String】【选填】加载全景图之前要显示的预览图像的URL&quot;, &quot;previewTitle&quot;:&quot;【String】【选填】显示加载按钮时要显示的标题&quot;, &quot;previewAuthor&quot;:&quot;【String】【选填】显示加载按钮时要显示的作者&quot;, &quot;horizonPitch&quot;:&quot;【int】【选填】图像地平线的俯仰，以度为单位（用于校正非分级全景图）&quot;, &quot;horizonRoll&quot;:&quot;【int】【选填】图像地平线的俯仰，以度为单位（用于校正非分级全景图）&quot;, &quot;animationTimingFunction&quot;:&quot;【Function】【选填】指定了一个计时函数，用于对运动进行动画处理&quot;, &quot;escapeHTML&quot;:&quot;【Boolean】【选填】如果为true，则HTML会从配置字符串中转义，以帮助缓解可能的情况DOM XSS攻击&quot;, &quot;crossOrigin&quot;:&quot;【String】【选填】指定了使用的CORS请求的类型&quot;, &quot;hotSpots&quot;:&quot;【Object】【选填】这指定了一个热点字典，可以链接到其他场景，信息或外部链接。每个数组元素都具有以下属性&quot;, &quot;- pitch&quot;:&quot;【int】【选填】指定热点位置的俯仰部分（以度为单位）&quot;, &quot;- yaw&quot;:&quot;【int】【选填】指定热点位置的偏航部分（以度为单位）&quot;, &quot;- type&quot;:&quot;【String】【选填】指定热点的类型。可以用于场景链接scene、信息热点info&quot;, &quot;- text&quot;:&quot;【String】【选填】指定了当用户将鼠标悬停在热点上时显示的文本&quot;, &quot;- attributes&quot;:&quot;【String】【选填】指定URL的链接属性,target当前页面、_blank新窗口&quot;, &quot;- sceneId&quot;:&quot;【String】【选填】指定要链接到的热点场景scene的ID，info不能用&quot;, &quot;- targetPitch&quot;:&quot;【int】【选填】指定目标场景的俯仰（以度为单位）&quot;, &quot;- targetYaw&quot;:&quot;【int】【选填】指定目标场景的偏航（以度为单位）&quot;, &quot;- targetHfov&quot;:&quot;【int】【选填】指定目标场景的 HFOV（以度为单位）&quot;, &quot;- id&quot;:&quot;【int】【选填】指定热点ID，用于API的函数&quot;, &quot;- cssClass&quot;:&quot;【String】【选填】热点的CSS类&quot;, &quot;- createTooltipFunc&quot;:&quot;【Function】【选填】创建热点DOM的函数&quot;, &quot;- createTooltipArgs&quot;:&quot;【Object】【选填】创建热点DOM的函数参数&quot;, &quot;- clickHandlerFunc&quot;:&quot;【Function】【选填】热点事件处理的函数&quot;, &quot;- clickHandlerArgs&quot;:&quot;【Object】【选填】热点事件处理的函数参数&quot;, &quot;- scale&quot;:&quot;【Boolean】【选填】对热点进行缩放以匹配视场的变化&quot;, &quot;hotSpotDebug&quot;:&quot;【Boolean】【选填】单击鼠标按钮，鼠标指针的俯仰和偏航将记录到控制台&quot;, &quot;sceneFadeDuration&quot;:&quot;【int】【选填】&quot;, &quot;capturedKeyNumbers&quot;:&quot;【阵列】【选填】&quot;, &quot;backgroundColor&quot;:&quot;【int，int，int】【选填】&quot;, &quot;avoidShowingBackground&quot;:&quot;【Boolean】【选填】防止显示部分全景图的超出范围的区域&quot;, &quot;panorama&quot;:&quot;【类型：equirectangular】【String】【选填】设置等距柱状投影全景图像的URL&quot;, &quot;haov&quot;:&quot;【类型：equirectangular】【int】【选填】设置全景图的水平视角（以度为单位）&quot;, &quot;vaov&quot;:&quot;【类型：equirectangular】【int】【选填】设置全景图的垂直视角（以度为单位）&quot;, &quot;vOffset&quot;:&quot;【类型：equirectangular】【int】【选填】设置等距柱状柱状投影图像中心的垂直偏移量地平线（以度为单位）&quot;, &quot;ignoreGPanoXMP&quot;:&quot;【类型：equirectangular】【Boolean】【选填】忽略任何嵌入&quot;, &quot;cubeMap&quot;:&quot;【类型：cubeMap】【Array】【选填】六个立方体面的URL数组&quot;, &quot;basePath&quot;:&quot;【类型：multires】【String】【选填】加载图像的基本路径&quot;, &quot;path&quot;:&quot;【类型：multires】【String】【选填】这是多分辨率切片位置的格式字符串&quot;, &quot;fallbackPath&quot;:&quot;【类型：multires】【String】【选填】这是CSS 3D的回退磁贴位置的格式字符串&quot;, &quot;extension&quot;:&quot;【类型：multires】【String】【选填】指定切片的文件扩展名&quot;, &quot;tileResolution&quot;:&quot;【类型：multires】【int】【选填】这指定了每个图像图块的大小（以像素为单位）&quot;, &quot;maxLevel&quot;:&quot;【类型：multires】【int】【选填】这指定了最大缩放级别&quot;, &quot;cubeResolution&quot;:&quot;【类型：multires】【int】【选填】这指定了面向图像的全分辨率立方体的大小（以像素为单位）&quot;&#125; API事件 load：在全景图完成加载时触发。 scenechange：在场景更改时触发。当load新场景完成加载。将场景ID字符串传递给处理程序。 fullscreenchange：在浏览器全屏状态更改时触发。将状态布尔值传递给处理程序。 zoomchange：在场景hfov更新时触发。将新的hfov值传递给处理程序。 scenechangefadedone：如果指定了场景过渡淡入淡出间隔，则在淡入淡出在切换场景后完成。 animatefinished：当任何移动&#x2F;动画完成时触发，即当渲染器停止时渲染新帧。将pitch、yaw、hfov传递给处理程序。 error：发生错误时触发。错误消息字符串将传递给事件侦听器。 errorcleared：清除错误时触发。 mousedown：按下鼠标按钮时触发。MouseEvent传递给处理程序。 mouseup：释放鼠标按钮时触发。MouseEvent传递给处理程序。 touchstart：在触摸开始时触发。TouchEvent传递给处理程序。 touchend：触摸结束时触发。TouchEvent传递给处理程序。 API","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"全景图展示","slug":"全景图展示","permalink":"https://aaajqhaaa.github.io/tags/%E5%85%A8%E6%99%AF%E5%9B%BE%E5%B1%95%E7%A4%BA/"},{"name":"Pannellum","slug":"Pannellum","permalink":"https://aaajqhaaa.github.io/tags/Pannellum/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Pannellum实现全景图编辑&预览","slug":"前端/webgl/Pannellum","date":"2024-01-17T01:03:03.000Z","updated":"2024-01-31T08:57:16.836Z","comments":true,"path":"2024/01/17/前端/webgl/Pannellum/","link":"","permalink":"https://aaajqhaaa.github.io/2024/01/17/%E5%89%8D%E7%AB%AF/webgl/Pannellum/","excerpt":"","text":"Pannellum实现全景图编辑&amp;预览 全景图片展示，需要支持热点 目标做一个全景图编辑界面，修改配置，绘制热点等功能，绘制完成之后，可以生成链接访问 介绍 github：https://github.com/mpetroff/pannellum.git 教程网站：https://pannellum.org/ Pannellum是一个轻量级、免费和开源的Web全景查看器。它使用HTML5、CSS3、JavaScript和WebGL构建，无需插件。 依赖下载123456&lt;!-- 最新编译和缩小的独立查看器 --&gt;https://cdn.pannellum.org/2.5/pannellum.htm&lt;!-- 最新编译和缩小的JavaScript --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js&quot;&gt;&lt;/script&gt;&lt;!-- 最新编译和缩小的CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css&quot;&gt; 全景图格式为equirectangular等距柱状投影，可以直接使用pannellum.htm访问打开 https://cdn.pannellum.org/2.5/pannellum.htm#panorama=https://pannellum.org/images/alma.jpg pannellum.htm访问打开也可以把配置写在json文件里面（config指定文件地址） https://cdn.pannellum.org/2.5/pannellum.htm#config=https://pannellum.org/configs/compass.json JSON配置选项12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&#123; &quot;type&quot;:&quot;【String】【选填】指定全景类型，cubemap、multires、equirectangular（默认）&quot;, &quot;title&quot;:&quot;【String】【选填】全景图的标题&quot;, &quot;author&quot;:&quot;【String】【选填】全景图的作者&quot;, &quot;authorURL&quot;:&quot;【String】【选填】全景图的作者URL，点击名字跳转&quot;, &quot;strings&quot;:&quot;【词典】【选填】不知道啥用&quot;, &quot;autoLoad&quot;:&quot;【Boolean】【选填】自动加载，默认false&quot;, &quot;autoRotate&quot;:&quot;【int】【选填】加载成功后自动旋转速度，正为逆时针、负为顺时针&quot;, &quot;autoRotateInactivityDelay&quot;:&quot;【int】【选填】用户活动停止后自动旋转速度，正为逆时针、负为顺时针【前提：autoRotate】&quot;, &quot;autoRotateStopDelay&quot;:&quot;【int】【选填】设置延迟多少毫秒后停止自动旋转【前提：autoRotate】&quot;, &quot;fallback&quot;:&quot;【String】【选填】用户设备或者链接不工作时，替换方案的URL&quot;, &quot;orientationOnByDefault&quot;:&quot;【Boolean】【选填】默认开启设备方向控制&quot;, &quot;showZoomCtrl&quot;:&quot;【Boolean】【选填】显示缩放控件&quot;, &quot;keyboardZoom&quot;:&quot;【Boolean】【选填】使用键盘缩放&quot;, &quot;mouseZoom&quot;:&quot;【Boolean、String】【选填】使用鼠标滚轮进行缩放false、true、fullscreenonly（只有全屏时支持）&quot;, &quot;draggable&quot;:&quot;【Boolean】【选填】鼠标和触摸拖动，默认true&quot;, &quot;friction&quot;:&quot;【number,0-1之间】【选填】惯性摩擦力，默认0.15&quot;, &quot;disableKeyboardCtrl&quot;:&quot;【Boolean】【选填】禁用键盘控件&quot;, &quot;showFullscreenCtrl&quot;:&quot;【Boolean】【选填】显示全屏控件&quot;, &quot;showControls&quot;:&quot;【Boolean】【选填】显示控件&quot;, &quot;touchPanSpeedCoeffFactor&quot;:&quot;【int】【选填】调整触摸输入的平移速度,默认1&quot;, &quot;yaw&quot;:&quot;【int】【选填】全景图的起始偏航位置（以度为单位）,默认0&quot;, &quot;pitch&quot;:&quot;【int】【选填】全景图的起始俯仰位置（以度为单位）,默认0&quot;, &quot;hfov&quot;:&quot;【int】【选填】全景图的起始水平视野（以度为单位）,默认100&quot;, &quot;minYaw&quot;:&quot;【int】【选填】全景图的最小偏航（以度为单位）,默认-180&quot;, &quot;maxYaw&quot;:&quot;【int】【选填】全景图的最大偏航（以度为单位）,默认180&quot;, &quot;minPitch&quot;:&quot;【int】【选填】全景图的最小间距（以度为单位）,默认-90&quot;, &quot;maxPitch&quot;:&quot;【int】【选填】全景图的最大间距（以度为单位）,默认90&quot;, &quot;minHfov&quot;:&quot;【int】【选填】全景图的最小水平视野（以度为单位）,默认50&quot;, &quot;maxHfov&quot;:&quot;【int】【选填】全景图的最大水平视野（以度为单位）,默认120&quot;, &quot;multiResMinHfov&quot;:&quot;【Boolean】【选填】自动计算的最小水平视野&quot;, &quot;compass&quot;:&quot;【Boolean】【选填】显示指南针&quot;, &quot;northOffset&quot;:&quot;【int】【选填】全景图中心与北的偏移量【前提：compass】&quot;, &quot;preview&quot;:&quot;【String】【选填】加载全景图之前要显示的预览图像的URL&quot;, &quot;previewTitle&quot;:&quot;【String】【选填】显示加载按钮时要显示的标题&quot;, &quot;previewAuthor&quot;:&quot;【String】【选填】显示加载按钮时要显示的作者&quot;, &quot;horizonPitch&quot;:&quot;【int】【选填】图像地平线的俯仰，以度为单位（用于校正非分级全景图）&quot;, &quot;horizonRoll&quot;:&quot;【int】【选填】图像地平线的俯仰，以度为单位（用于校正非分级全景图）&quot;, &quot;animationTimingFunction&quot;:&quot;【Function】【选填】指定了一个计时函数，用于对运动进行动画处理&quot;, &quot;escapeHTML&quot;:&quot;【Boolean】【选填】如果为true，则HTML会从配置字符串中转义，以帮助缓解可能的情况DOM XSS攻击&quot;, &quot;crossOrigin&quot;:&quot;【String】【选填】指定了使用的CORS请求的类型&quot;, &quot;hotSpots&quot;:&quot;【Object】【选填】这指定了一个热点字典，可以链接到其他场景，信息或外部链接。每个数组元素都具有以下属性&quot;, &quot;- pitch&quot;:&quot;【int】【选填】指定热点位置的俯仰部分（以度为单位）&quot;, &quot;- yaw&quot;:&quot;【int】【选填】指定热点位置的偏航部分（以度为单位）&quot;, &quot;- type&quot;:&quot;【String】【选填】指定热点的类型。可以用于场景链接scene、信息热点info&quot;, &quot;- text&quot;:&quot;【String】【选填】指定了当用户将鼠标悬停在热点上时显示的文本&quot;, &quot;- attributes&quot;:&quot;【String】【选填】指定URL的链接属性,target当前页面、_blank新窗口&quot;, &quot;- sceneId&quot;:&quot;【String】【选填】指定要链接到的热点场景scene的ID，info不能用&quot;, &quot;- targetPitch&quot;:&quot;【int】【选填】指定目标场景的俯仰（以度为单位）&quot;, &quot;- targetYaw&quot;:&quot;【int】【选填】指定目标场景的偏航（以度为单位）&quot;, &quot;- targetHfov&quot;:&quot;【int】【选填】指定目标场景的 HFOV（以度为单位）&quot;, &quot;- id&quot;:&quot;【int】【选填】指定热点ID，用于API的函数&quot;, &quot;- cssClass&quot;:&quot;【String】【选填】热点的CSS类&quot;, &quot;- createTooltipFunc&quot;:&quot;【Function】【选填】创建热点DOM的函数&quot;, &quot;- createTooltipArgs&quot;:&quot;【Object】【选填】创建热点DOM的函数参数&quot;, &quot;- clickHandlerFunc&quot;:&quot;【Function】【选填】热点事件处理的函数&quot;, &quot;- clickHandlerArgs&quot;:&quot;【Object】【选填】热点事件处理的函数参数&quot;, &quot;- scale&quot;:&quot;【Boolean】【选填】对热点进行缩放以匹配视场的变化&quot;, &quot;hotSpotDebug&quot;:&quot;【Boolean】【选填】单击鼠标按钮，鼠标指针的俯仰和偏航将记录到控制台&quot;, &quot;sceneFadeDuration&quot;:&quot;【int】【选填】&quot;, &quot;capturedKeyNumbers&quot;:&quot;【阵列】【选填】&quot;, &quot;backgroundColor&quot;:&quot;【int，int，int】【选填】&quot;, &quot;avoidShowingBackground&quot;:&quot;【Boolean】【选填】防止显示部分全景图的超出范围的区域&quot;, &quot;panorama&quot;:&quot;【类型：equirectangular】【String】【选填】设置等距柱状投影全景图像的URL&quot;, &quot;haov&quot;:&quot;【类型：equirectangular】【int】【选填】设置全景图的水平视角（以度为单位）&quot;, &quot;vaov&quot;:&quot;【类型：equirectangular】【int】【选填】设置全景图的垂直视角（以度为单位）&quot;, &quot;vOffset&quot;:&quot;【类型：equirectangular】【int】【选填】设置等距柱状柱状投影图像中心的垂直偏移量地平线（以度为单位）&quot;, &quot;cubeMap&quot;:&quot;【类型：cubeMap】【Array】【选填】六个立方体面的URL数组&quot;, &quot;basePath&quot;:&quot;【类型：multires】【String】【选填】加载图像的基本路径&quot;, &quot;path&quot;:&quot;【类型：multires】【String】【选填】这是多分辨率切片位置的格式字符串&quot;, &quot;fallbackPath&quot;:&quot;【类型：multires】【String】【选填】这是CSS 3D的回退磁贴位置的格式字符串&quot;, &quot;extension&quot;:&quot;【类型：multires】【String】【选填】指定切片的文件扩展名&quot;, &quot;tileResolution&quot;:&quot;【类型：multires】【int】【选填】这指定了每个图像图块的大小（以像素为单位）&quot;, &quot;maxLevel&quot;:&quot;【类型：multires】【int】【选填】这指定了最大缩放级别&quot;, &quot;cubeResolution&quot;:&quot;【类型：multires】【int】【选填】这指定了面向图像的全分辨率立方体的大小（以像素为单位）&quot;&#125; API事件 load：在全景图完成加载时触发。 scenechange：在场景更改时触发。当load新场景完成加载。将场景ID字符串传递给处理程序。 fullscreenchange：在浏览器全屏状态更改时触发。将状态布尔值传递给处理程序。 zoomchange：在场景hfov更新时触发。将新的hfov值传递给处理程序。 scenechangefadedone：如果指定了场景过渡淡入淡出间隔，则在淡入淡出在切换场景后完成。 animatefinished：当任何移动&#x2F;动画完成时触发，即当渲染器停止时渲染新帧。将pitch、yaw、hfov传递给处理程序。 error：发生错误时触发。错误消息字符串将传递给事件侦听器。 errorcleared：清除错误时触发。 mousedown：按下鼠标按钮时触发。MouseEvent传递给处理程序。 mouseup：释放鼠标按钮时触发。MouseEvent传递给处理程序。 touchstart：在触摸开始时触发。TouchEvent传递给处理程序。 touchend：触摸结束时触发。TouchEvent传递给处理程序。","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"全景图展示","slug":"全景图展示","permalink":"https://aaajqhaaa.github.io/tags/%E5%85%A8%E6%99%AF%E5%9B%BE%E5%B1%95%E7%A4%BA/"},{"name":"Pannellum","slug":"Pannellum","permalink":"https://aaajqhaaa.github.io/tags/Pannellum/"},{"name":"webgl","slug":"webgl","permalink":"https://aaajqhaaa.github.io/tags/webgl/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"全景图展示技术选型","slug":"前端/threejs/qjt","date":"2024-01-15T02:17:46.000Z","updated":"2024-01-30T02:28:29.739Z","comments":true,"path":"2024/01/15/前端/threejs/qjt/","link":"","permalink":"https://aaajqhaaa.github.io/2024/01/15/%E5%89%8D%E7%AB%AF/threejs/qjt/","excerpt":"","text":"全景图展示技术选型 全景图片展示，需要支持热点 目标做一个全景图编辑界面，修改配置，绘制热点等功能，绘制完成之后，可以生成链接访问 全景图格式 等距柱状投影either equirectangular：最简单，只需单张图片，最好限制最大图像大小宽度为4096px 立方体贴图cube map：需要六张图像，但支持更高分辨率的全景图，由于绝大多数设备支持最大4096像素的立方体面 多分辨率格式multiresolution formats：此格式是基于立方体贴图的格式，但每个立方体面都是平铺图像金字塔，而不是单个图像。（缺点是需要额外的工作将图像转换为该图像以及必须托管的大量文件） three.js github：https://github.com/mrdoob/three.js.git 教程网站：https://threejs.org/ CND引入、npm引入 Panolens【不推荐】 github：https://github.com/pchen66/panolens.js.git 教程网站：https://pchen66.github.io/Panolens/ 基于threeJS的库，已经不更新了 API参数没有说明（难用），效果不好 CDN引入 demo运行：需要three.min.js、panolens.min.js、view.jpg(全景图)12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试Panolens&lt;/title&gt; &lt;style&gt; html,body&#123; padding: 0; margin: 0; width:100%; height:100%; overflow: hidden; &#125; #container &#123; width:100%; height:100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;script src=&quot;../js/three.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../js/panolens.min.js&quot;&gt;&lt;/script&gt;、&lt;script&gt; const container = document.querySelector(&#x27;#container&#x27;); const viewer = new PANOLENS.Viewer(&#123; container: container, controlBar: false &#125;); const panorama = new PANOLENS.ImagePanorama(&#x27;../view.jpg&#x27;); panorama.addEventListener(&#x27;enter-fade-start&#x27;, function(position)&#123; viewer.setControlCenter(position); &#125;.bind( this, new THREE.Vector3( -5000.00, 167.06, 3449.90 ))); viewer.add(panorama);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Pannellum github：https://github.com/mpetroff/pannellum.git 教程网站：https://pannellum.org/ 基于webgl，有参数说明 CDN引入 demo运行：需要pannellum.css、pannellum.js、view.jpg(全景图)1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试Pannellum&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css&quot;/&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js&quot;&gt;&lt;/script&gt; &lt;style&gt; html,body&#123; padding: 0; margin: 0; width:100%; height:100%; overflow: hidden; &#125; #container &#123; width:100%; height:100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;script&gt;pannellum.viewer(&#x27;container&#x27;, &#123; &quot;type&quot;: &quot;equirectangular&quot;,// 全景类型：cubemap、multires、equirectangular &quot;panorama&quot;: &quot;../view.jpg&quot;, &quot;autoLoad&quot;: true, // 自动加载 &quot;autoRotate&quot;: -2, // 自动旋转 //&quot;preview&quot;: &quot;/images/xxx.jpg&quot;, // 预览的图片 &quot;title&quot;: &quot;我的标题&quot;, // 标题 &quot;author&quot;: &quot;作者JQH&quot;, // 作者 &quot;compass&quot;: true, // 指南针 &quot;northOffset&quot;: 247.5, // 北方偏移量 &quot;pitch&quot;: 2.3, // 起始俯仰位置 &quot;yaw&quot;: 150, // 起始偏航位置 &quot;hfov&quot;: 130 // 起始水平视野&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Marzipano github：https://github.com/google/marzipano.git marzipano-tool：https://github.com/foyez/marzipano-tool.git 教程网站：https://www.marzipano.net/ API文档：https://www.marzipano.net/reference/ 基于webgl，有参数说明 CND引入、npm引入 demo运行：需要marzipano.js、view.jpg(全景图)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试Marzipano&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;target-densitydpi=device-dpi, width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui&quot; /&gt; &lt;style&gt; @-ms-viewport &#123; width: device-width; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/marzipano.js&quot;&gt;&lt;/script&gt; &lt;style&gt; * &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; -webkit-user-drag: none; -webkit-touch-callout: none; -ms-content-zooming: none; &#125; html, body &#123; width: 100%; height: 100%; padding: 0; margin: 0; overflow: hidden; &#125; #container &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;script&gt; // 创建viewer. var viewer = new Marzipano.Viewer(document.getElementById(&#x27;container&#x27;)); // 创建source. var source = Marzipano.ImageUrlSource.fromString( &quot;../view.jpg&quot; ); // 创建geometry. var geometry = new Marzipano.EquirectGeometry([&#123; width: 4000 &#125;]); // 创建view. var limiter = Marzipano.RectilinearView.limit.traditional(1024, 100*Math.PI/180); var view = new Marzipano.RectilinearView(&#123; yaw: Math.PI &#125;, limiter); // 创建scene. var scene = viewer.createScene(&#123; source: source, geometry: geometry, view: view, pinFirstLevel: true &#125;); // 展示scene. scene.switchTo();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; view360【不推荐】 教程网站：https://naver.github.io/egjs-view360/ 基于threejs CND引入、npm引入 v4版本在测试阶段，有API文档【v3版本有点模糊】123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试view360&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://naver.github.io/egjs-view360/release/latest/css/view360.min.css&quot;&gt; &lt;script src=&quot;../js/view360.pkgd.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; html,body&#123; padding: 0; margin: 0; width:100%; height:100%; overflow: hidden; &#125; #container &#123; width:100%; height:100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;view360-container is-16by9&quot; id=&quot;container&quot;&gt; &lt;canvas class=&quot;view360-canvas&quot;/&gt; &lt;/div&gt; &lt;script&gt; const PanoViewer = eg.view360.PanoViewer; const panoViewer = new PanoViewer( document.getElementById(&quot;container&quot;), &#123; image: &quot;../view.jpg&quot; &#125; ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Photo Sphere Viewer github：https://github.com/mistic100/Photo-Sphere-Viewer.git 教程网站：https://photo-sphere-viewer.js.org/guide/ 基于threejs CND引入、npm引入 有API文档12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试Photo Sphere Viewer&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@photo-sphere-viewer/core/index.min.css&quot; /&gt; &lt;style&gt; html,body&#123; padding: 0; margin: 0; width:100%; height:100%; overflow: hidden; &#125; #container &#123; width:100%; height:100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot; style=&quot;width: 100vw; height: 100vh;&quot;&gt;&lt;/div&gt;&lt;script type=&quot;importmap&quot;&gt; &#123; &quot;imports&quot;: &#123; &quot;three&quot;: &quot;https://cdn.jsdelivr.net/npm/three/build/three.module.js&quot;, &quot;@photo-sphere-viewer/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@photo-sphere-viewer/core/index.module.js&quot; &#125; &#125;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; import &#123; Viewer &#125; from &#x27;@photo-sphere-viewer/core&#x27;; const viewer = new Viewer(&#123; container: document.querySelector(&#x27;#container&#x27;), panorama: &#x27;../view.jpg&#x27;, &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 全景图概念 摄像机的视角和观察方向 Pitch（俯仰角）：俯仰角描述了摄像机的垂直旋转角度，即相对于地平线的角度。当俯仰角为0时，摄像机视线水平朝向前方；当俯仰角为正值时，摄像机视线向上偏离地平线；当俯仰角为负值时，摄像机向下偏离地平线。 Yaw（偏航角）：偏航角描述了摄像机的水平旋转角度，即相对于参考方向（通常为正北方向）的角度。当偏航角为0时，摄像机视线指向参考方向；当偏航角为正值时，摄像机顺时针旋转；当偏航角为负值时，摄像机逆时针旋转。 HFOV（水平视场角）：水平视场角描述了摄像机在水平方向上能够捕捉到的视野范围。它表示了从摄像机视线的左侧到右侧所能看到的角度范围。","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"全景图展示","slug":"全景图展示","permalink":"https://aaajqhaaa.github.io/tags/%E5%85%A8%E6%99%AF%E5%9B%BE%E5%B1%95%E7%A4%BA/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"代理","slug":"其他/proxy","date":"2024-01-04T08:51:03.000Z","updated":"2024-01-18T00:35:49.326Z","comments":true,"path":"2024/01/04/其他/proxy/","link":"","permalink":"https://aaajqhaaa.github.io/2024/01/04/%E5%85%B6%E4%BB%96/proxy/","excerpt":"","text":"代理 所处的位置：都是客户端和真实服务器之间； 所做的事情：都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端； 正向代理 正向代理是客户端的代理，服务器不知道真正的客户端是谁； 正向代理一般是客户端架设的； 正向代理主要是用来解决访问限制问题； 反向代理 反向代理是服务器的代理，客户端不知道真正的服务器是谁； 反向代理一般是服务器架设的； 反向代理则是提供负载均衡、安全防护等作用；","categories":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"正向代理","slug":"正向代理","permalink":"https://aaajqhaaa.github.io/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"},{"name":"反向代理","slug":"反向代理","permalink":"https://aaajqhaaa.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"应用国际化","slug":"后端/springboot/gjh","date":"2024-01-04T04:59:23.000Z","updated":"2024-01-18T00:35:49.336Z","comments":true,"path":"2024/01/04/后端/springboot/gjh/","link":"","permalink":"https://aaajqhaaa.github.io/2024/01/04/%E5%90%8E%E7%AB%AF/springboot/gjh/","excerpt":"","text":"应用国际化前端国际化 页面显示和用户界面的本地化 方案：React Intl、Vue I18n、Angular i18n 后端国际化 处理与业务逻辑和数据相关的国际化 概念 java.util.Locale类：本地化语言类，包含各个国家地区的语言languages org.springframework.context.MessageSource：其主要是根据Locale信息获取对应的国际化消息的集合，然后根据code获取对应的消息 org.springframework.web.servlet.LocaleResolver：设置当前会话默认的国际化语言 步骤 1、创建国际化文件resources/i18n/messages message.properties message_cn_ZH.properties message_en_GB.properties 2、yml指定国际化1234spring: messages: basename: i18n/messages encoding: UTF-8 3、创建国际化表i18n_message（除了可以存在配置文件，也可以存在数据库） 属性名 国家代码 对应内容 PASSWORD cn_ZH 密码 PASSWORD en_GB password AGE cn_ZH 年龄 AGE en_GB age 4、表对应实体类以及Dao123456789101112131415161718@Data@Builder@NoArgsConstructor@AllArgsConstructor@TableName(&quot;i18n_message&quot;)@ApiModel(description = &quot;国际化表&quot;)public class I18nMessage &#123; @ApiModelProperty(&quot;属性名&quot;) private String code; @ApiModelProperty(&quot;国家代码&quot;) private String locale; @ApiModelProperty(&quot;对应内容&quot;) private String message;&#125; 12@Mapperpublic interface I18nMessageMapper extends BaseMapper&lt;I18nMessage&gt; &#123; &#125; 5、自定义MessageSource类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@Component(&quot;messageSource&quot;)public class CustomMessageSource extends AbstractMessageSource implements InitializingBean &#123; @Resource private I18nMessageMapper i18nMessageMapper; /** * 这个是用来缓存数据库中获取到的配置的（可以改到redis） * 数据库配置更改的时候可以调用reload方法重新加载 */ private static final Map&lt;String, Map&lt;String, String&gt;&gt; LOCAL_CACHE = new ConcurrentHashMap&lt;&gt;(); /** * Bean属性初始化完成之后执行 */ @Override public void afterPropertiesSet() &#123; this.reload(); &#125; /** * 重新加载消息到该类的Map缓存中 */ public void reload() &#123; LOCAL_CACHE.clear();// 清除该类的缓存 LOCAL_CACHE.putAll(this.loadAllMessageResources());// 加载所有的国际化资源 &#125; /** * 加载所有的国际化消息资源 * 同时从数据库和properties文件中读取国际化信息 * Map&lt;LanguageCode, Map&lt;code, 翻译&gt;&gt; */ private Map&lt;String, Map&lt;String, String&gt;&gt; loadAllMessageResources() &#123; // todo 从数据库中查询所有的国际化资源 List&lt;I18nMessage&gt; allLocaleMessage = i18nMessageMapper.selectAllList(); allLocaleMessage = Optional.OfNullable(allLocaleMessage).orElseGet(() -&gt; new ArrayList&lt;&gt;()); // 将查询到的国际化资源转换为 Map&lt;地区码, Map&lt;code, 信息&gt;&gt; 的数据格式 Map&lt;String, Map&lt;String, String&gt;&gt; localeMsgMap = allLocaleMessage.stream().collect(Collectors.groupingBy(I18message::getLocale, Collectors.toMap(I18nMessage::getCode, I18nMessage::getMessage))); // 获取国家地区List List&lt;Locale&gt; localeList = localeMsgMap.keySet().stream().map(Locale::new).collect(Collectors.toList()); for (Locale locale : localeList) &#123; // todo 按照国家地区来读取本地的国际化资源文件,我们的国际化资源文件放在i18n文件夹之下 ResourceBundle resourceBundle = ResourceBundle.getBundle(&quot;i18n/messages&quot;, locale); Set&lt;String&gt; keySet = resourceBundle.keySet();// 获取国际化资源文件中的key Map&lt;String, String&gt; msgFromFileMap = keySet.stream().collect(Collectors.toMap(Function.identity(), resourceBundle::getString));// 将 code=信息 格式的数据收集为 Map&lt;code,信息&gt; 的格式 // 将本地的国际化信息和数据库中的国际化信息合并 Map&lt;String, String&gt; localeFileMsgMap = localeMsgMap.get(locale.getLanguage()); localeFileMsgMap.putAll(msgFromFileMap);// 配置文件会覆盖数据库的 localeMsgMap.put(locale.getLanguage(), localeFileMsgMap); &#125; return localeMsgMap; &#125; /** * 缓存Map中get国际化资源 */ private String getSourceFromCacheMap(String code, Locale locale) &#123; String language = ObjectUtils.isEmpty(locale) ? LocaleContextHolder.getLocale().getLanguage() : locale.getLanguage(); // 获取缓存中对应语言的所有数据项 Map&lt;String, String&gt; propMap = LOCAL_CACHE.get(language); // 找到直接返回，找不到返回code return Optional.OfNullable(propMap.get(code)).orElse(code); &#125; /** * 实现方法，供AbstractMessageSource.getMessage方法内部使用 */ @Override protected MessageFormat resolveCode(String code, Locale locale) &#123; String msg = this.getSourceFromCacheMap(code, locale); return new MessageFormat(msg, locale); &#125; /** * 实现方法，供AbstractMessageSource.getMessage方法内部使用 */ @Override protected String resolveCodeWithoutArguments(String code, Locale locale) &#123; return this.getSourceFromCacheMap(code, locale); &#125;&#125; 6、自定义LocaleResolver国际化区域解析器，解析url或者header中的参数 1234567891011121314151617181920212223242526272829303132@Componentpublic class CustomLocaleResolver implements LocaleResolver &#123; /** * 根据当前请求解析当前请求的本地化信息 */ @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; String l = httpServletRequest.getParameter(&quot;lang&quot;);// 请求url参数 String header = httpServletRequest.getHeader(&quot;lang&quot;);// 请求头参数 Locale locale = null;// 国际化，每一个locale对象都代表一个特定的政治文化，地区和创建方法 return Optional.OfNullable(l).map(i -&gt; &#123; // 判断请求url参数中是否有带lang参数（优先） String[] split = l.split(&quot;_&quot;);// 根据下划线分割 return new Locale(split[0], split[1]);// 创建国际化对象 &#125;).orElseGet(() -&gt; &#123; return Optional.OfNullable(header).map(i -&gt; &#123; // 判断请求头参数中是否有带lang参数 header = header.replaceAll(&quot;\\&quot;&quot;,&quot;&quot;);// 替换为空 String[] split = header.split(&quot;_&quot;);// 根据下划线分割 return new Locale(split[0], split[1]);// 创建国际化对象 &#125;).orElse(null); &#125;); &#125; /** * 设置当前请求、响应的本地化信息 */ @Override public void setLocale(HttpServletRequest httpServletRequest, @Nullable HttpServletResponse httpServletResponse, @Nullable Locale locale) &#123; &#125;&#125; 7、封装工具类 12345678910111213141516171819202122232425262728293031323334@Componentpublic class I18nMessageUtil &#123; private final MessageSource messageSource; /** * @param code 对应messages配置的key * @return String */ public String getMessage(String code)&#123; return getMessage(code, null); &#125; /** * @param code 对应messages配置的key * @param args 数组参数 * @return String */ public String getMessage(String code,Object[] args)&#123; return getMessage(code, args, &quot;&quot;); &#125; /** * @param code 对应messages配置的key * @param args 数组参数 * @param defaultMessage 没有设置key的时候的默认值 * @return String */ public String getMessage(String code,Object[] args,String defaultMessage)&#123; return messageSource.getMessage(code, args, defaultMessage, LocaleContextHolder.getLocale()); &#125;&#125; 使用场景 1、全局响应状态码（code）对应的消息（msg）国际化 法一：工具类中，将MessageSource做静态变量注入，提供几个静态方法进行国际化，在new Result()的时候调用静态方法进行国际化 【@Component+有参构造函数@Autowired注入】12345678910111213141516171819202122232425262728293031323334353637@Componentpublic class I18nMessageUtil &#123; private static MessageSource messageSource; @Autowired public I18nMessageUtil(MessageSource messageSource)&#123; I18nMessageUtil.messageSource = messageSource; &#125; /** * @param code 对应messages配置的key * @return String */ public static String getMessage(String code)&#123; return getMessage(code, null); &#125; /** * @param code 对应messages配置的key * @param args 数组参数 * @return String */ public static String getMessage(String code,Object[] args)&#123; return getMessage(code, args, &quot;&quot;); &#125; /** * @param code 对应messages配置的key * @param args 数组参数 * @param defaultMessage 没有设置key的时候的默认值 * @return String */ public static String getMessage(String code,Object[] args,String defaultMessage)&#123; return messageSource.getMessage(code, args, defaultMessage, LocaleContextHolder.getLocale()); &#125;&#125; 法二：AOP切面，@AfterReturning中获取返回对象，修改里面的属性值（对象是不能修改的成一个新的滴） 2、接口参数校验结果国际化 @NotBlank(message=&quot;&#123;xxx_err_code&#125;&quot;)","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"后端/前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot/"},{"name":"SpringBoot项目必备","slug":"SpringBoot项目必备","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%85%E5%A4%87/"},{"name":"SpringBoot国际化","slug":"SpringBoot国际化","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot%E5%9B%BD%E9%99%85%E5%8C%96/"},{"name":"SpringBoot I18n","slug":"SpringBoot-I18n","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot-I18n/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"后端/前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/%E5%89%8D%E7%AB%AF/"}]},{"title":"EnableAspectJAutoProxy","slug":"后端/springboot/EnableAspectJAutoProxy","date":"2024-01-02T04:47:32.000Z","updated":"2024-01-18T00:35:49.334Z","comments":true,"path":"2024/01/02/后端/springboot/EnableAspectJAutoProxy/","link":"","permalink":"https://aaajqhaaa.github.io/2024/01/02/%E5%90%8E%E7%AB%AF/springboot/EnableAspectJAutoProxy/","excerpt":"","text":"@EnableAspectJAutoProxy 切面配置注解@EnableAspectJAutoProxy proxyTargetClass设置代理类型 exposeProxy设置代理类是否可以通过AopContext访问1234567891011121314151617181920212223242526package org.springframework.context.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(AspectJAutoProxyRegistrar.class)public @interface EnableAspectJAutoProxy &#123; /** * 是否要创建基于子类(CGLIB)的代理，而不是基于标准Java接口的代理。默认值是&#123;@code false&#125;。 */ boolean proxyTargetClass() default false; /** * 表明代理应该由AOP框架作为ThreadLocal公开，以便通过AopContext进行检索。 * 默认为关闭，即AopContext访问不到。 */ boolean exposeProxy() default false;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot/"},{"name":"SpringBoot注解","slug":"SpringBoot注解","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot%E6%B3%A8%E8%A7%A3/"},{"name":"AOP切面","slug":"AOP切面","permalink":"https://aaajqhaaa.github.io/tags/AOP%E5%88%87%E9%9D%A2/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"SpringBoot参数校验","slug":"后端/springboot/csjy","date":"2023-12-30T08:49:39.000Z","updated":"2024-01-18T00:35:49.336Z","comments":true,"path":"2023/12/30/后端/springboot/csjy/","link":"","permalink":"https://aaajqhaaa.github.io/2023/12/30/%E5%90%8E%E7%AB%AF/springboot/csjy/","excerpt":"","text":"SpringBoot参数校验12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;&#123;&#125;&lt;/version&gt;&lt;/dependency&gt; @Valid注解 由javax提供（标准JSR-303规范） 使用地方：方法、方法参数、成员属性（字段） 功能：【支持嵌套验证】 注解 作用 类型 @AssertFalse 限制必须为false boolean、Boolean @AssertTrue 限制必须为true 同上 @Future 限制必须是一个将来的日期 Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate @FutureOrPresent 未来或当前的日期，此处的present概念是相对于使用约束的类型定义的。例如校验的参数为Year year &#x3D; Year.now();此时约束是一年，那么“当前”将表示当前的整个年份。 同上 @PastOrPresent 过去或者当前时间，和@FutureOrPresent类似 同上 @Past 限制必须是一个过去的日期 同上 @Max(value) 限制必须为一个不大于指定值的数字 BigDecimal、BigInteger、byte, short, int, long @Min(value) 限制必须为一个不小于指定值的数字 同上 @Size(max,min) 限制字符长度必须在min到max之间 同上 @DecimalMax(value) 限制必须为一个不大于指定值的数字 同上 @DecimalMin(value) 限制必须为一个不小于指定值的数字 同上 @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction 同上 @PositiveOrZero 包含正数和零，空元素有效可以校验通过 同上 @Negative 绝对的负数，不能包含零，空元素有效可以校验通过 同上 @NegativeOrZero 包含负数和零，空元素有效可以校验通过 同上 @Positive 绝对的正数，不能包含零，空元素有效可以校验通过 同上 @NotBlank 验证注解的元素值不为空（不为null、trim()去除首位空格后长度为0） String @Pattern(value) 限制必须符合指定的正则表达式 同上 @Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 同上 @NotEmpty 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） CharSequence、Collection、Map、Array @NotNull 限制必须不为null 所有类型 @Null 限制只能为null 同上 使用 嵌套校验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Project &#123; @NotBlank(message = &quot;ID不能为空&quot;) private String id; @NotBlank @Pattern(regexp = &quot;[a-zA-Z0-9]&quot;, message = &quot;只允许输入数字和字母&quot;) private String strValue; @NotNull(message = &quot;不能为空&quot;) @Min(value = -99, message = &quot;值不能小于-99&quot;) @Max(value = 100, message = &quot;值不能超过100&quot;) private Integer intValue; @NotNull(message = &quot;不能为空&quot;) @Negative(message = &quot;值必须为负数&quot;) private Integer negativeValue; @NotNull(message = &quot;不能为空&quot;) @Valid// todo 嵌套校验 private Team team; &#125;@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Team &#123; @FutureOrPresent(message = &quot;只能输入当前年份或未来的年份&quot;) private Year nowYear; @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @Future(message = &quot;只能是未来的时间&quot;) private Date futureTime; @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @Past(message = &quot;只能是过去的时间&quot;) private Date pastTime; @Email(message = &quot;请输入正确的邮箱&quot;) private String email; @NotNull(message = &quot;不能为空&quot;) @Valid// todo 嵌套校验 private List&lt;Member&gt; list; &#125;@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Member &#123; @NotBlank(message = &quot;姓名不能为空&quot;) private String name; &#125;@RestController@RequestMapping(&quot;/valid&quot;)public class TestValidController &#123; @PostMapping(&quot;/userInfo&quot;) public BaseResponse userInfo(@Valid @RequestBody Team team) &#123; return new BaseResponse(team); &#125;&#125; @Validated注解 由Spring提供（Spring&#39;s JSR-303规范） 使用地方：类、方法、方法参数 功能：【支持分组验证】【能配合@Valid进行嵌套验证】 使用 一、分组校验 场景：保存草稿时某些字段不用校验，提交时都要校验，更新时id要校验不为空； 1、自定义分组123456789101112public interface MyValidGroup &#123; // 保存草稿 interface SaveDraft &#123; &#125; // 提交表单 interface Submit &#123; &#125; // 更新数据 interface Update &#123; &#125; &#125; 2、设置分组（不设置分组时属于Default.class默认分组）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Project &#123; @NotBlank(message = &quot;ID不能为空&quot;, groups = &#123;MyValidGroup.Update.class&#125;)// 更新时要校验id不为空 private String id; @NotBlank(message = &quot;项目老大不能为空&quot;, groups = &#123;MyValidGroup.SaveDraft.class,MyValidGroup.Submit.class,MyValidGroup.Update.class&#125;) private String leader; @NotBlank(message = &quot;ID不能为空&quot;) @Pattern(regexp = &quot;[a-zA-Z0-9]&quot;, message = &quot;只允许输入数字和字母&quot;) private String strValue; @NotNull(message = &quot;不能为空&quot;) @Min(value = -99, message = &quot;值不能小于-99&quot;) @Max(value = 100, message = &quot;值不能超过100&quot;) private Integer intValue; @NotNull(message = &quot;不能为空&quot;) @Negative(message = &quot;值必须为负数&quot;) private Integer negativeValue; @NotNull(message = &quot;不能为空&quot;) @Valid// todo 嵌套校验 private Team team; &#125;@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Team &#123; @FutureOrPresent(message = &quot;只能输入当前年份或未来的年份&quot;) private Year nowYear; @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @Future(message = &quot;只能是未来的时间&quot;) private Date futureTime; @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @Past(message = &quot;只能是过去的时间&quot;) private Date pastTime; @Email(message = &quot;请输入正确的邮箱&quot;) private String email; @NotNull(message = &quot;不能为空&quot;) @Valid// todo 嵌套校验 private List&lt;Member&gt; list; &#125;@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Member &#123; @NotBlank(message = &quot;姓名不能为空&quot;) private String name; &#125;@RestController@RequestMapping(&quot;/valid&quot;)public class TestValidController &#123; // todo Validated不配置时校验默认分组 @PostMapping(&quot;/all&quot;) public BaseResponse all(@Validated @RequestBody ProjectDTO testAnnotationDto) &#123; return new BaseResponse(testAnnotationDto); &#125; // todo 保存草稿：校验草稿分组 @PostMapping(&quot;/saveDraft&quot;) public BaseResponse saveDraft(@Validated(value = &#123;TestValidGroup.SaveDraft.class&#125;) @RequestBody ProjectDTO testAnnotationDto) &#123; return new BaseResponse(testAnnotationDto); &#125; // todo 提交：校验提交分组和默认分组 @PostMapping(&quot;/submit&quot;) public BaseResponse submit(@Validated(value = &#123;MyValidGroup.Submit.class, Default.class&#125;) @RequestBody ProjectDTO testAnnotationDto) &#123; return new BaseResponse(testAnnotationDto); &#125; // todo 更新：校验更新分组和默认分组 @PostMapping(&quot;/update&quot;) public BaseResponse update(@Validated(value = &#123;MyValidGroup.Update.class, Default.class&#125;) @RequestBody ProjectDTO testAnnotationDto) &#123; return new BaseResponse(testAnnotationDto); &#125;&#125; 二、分组校验指定顺序@GroupSequence 使用在分组接口上1234567891011121314151617181920212223242526272829303132public interface MyValidGroup &#123; // 先校验XXX分组，再校验YYY分组 @GroupSequence(value = &#123;XXX.class, YYY.class&#125;) interface Update &#123; &#125; interface XXX &#123; &#125; interface YYY &#123; &#125;&#125;@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Project &#123; @NotBlank(message = &quot;ID不能为空&quot;, groups = &#123;MyValidGroup.XXX.class&#125;)// 更新时要校验id不为空 private String id; @NotBlank(message = &quot;项目老大不能为空&quot;, groups = &#123;MyValidGroup.YYY.class&#125;) private String leader;&#125;@RestController@RequestMapping(&quot;/valid&quot;)public class TestValidController &#123; @PostMapping(&quot;/post&quot;) public BaseResponse testValidPostRequest(@Validated(value = &#123;MyValidGroup.Update.class&#125;) @RequestBody ProjectDTO testAnnotationDto) &#123; return new BaseResponse(testAnnotationDto); &#125;&#125; 三、快速失败机制（默认是校验所有参数，返回所有有问题的） 123456789101112@Configurationpublic class ValidConfig &#123; @Bean public Validator validator() &#123; ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class).configure() .failFast(true)// todo 快速失败模式 .buildValidatorFactory(); return validatorFactory.getValidator(); &#125; &#125; 四、自定义校验注解（百度） @Constraint(validatedBy = XXXValidator.class)：指定我们自定义的校验类 public class XXXValidator implements ConstraintValidator&lt;XXX, String&gt; &#123;&#125;：自定义校验类 五、全局异常处理，统一返回校验异常信息 12345678910111213141516@Slf4j@RestControllerAdvicepublic class ExceptionHandlerConfig &#123; /** * 拦截valid参数校验返回的异常，并转化成基本的返回样式 */ @ExceptionHandler(value = MethodArgumentNotValidException.class) public Result dealMethodArgumentNotValidException(MethodArgumentNotValidException e) &#123; log.error(&quot;校验异常：&quot;, e); List&lt;ObjectError&gt; allErrors = e.getBindingResult().getAllErrors(); String message = allErrors.stream() .map(s -&gt; s.getDefaultMessage()) .collect(Collectors.joining(&quot;;&quot;)); return Result.builder().code(&quot;-10&quot;).msg(message).build(); &#125;&#125; 六、不同分组下采用不同校验 12345678910111213141516@Data@AllArgsConstructor@NoArgsConstructor@SuperBuilderpublic class Base &#123; @NotBlank.List(&#123; @NotBlank(message = &quot;Project不能为空&quot;, groups = &#123;MyValidGroup.Project.class&#125;), @NotBlank(message = &quot;Team不能为空&quot;, groups = &#123;MyValidGroup.Team.class&#125;) &#125;) private String baseId; @Max(value = 10, message = &quot;Project不能大于10&quot;, groups = &#123;MyValidGroup.Project.class&#125;) @Max(value = 30, message = &quot;Team不能大于30&quot;, groups = &#123;MyValidGroup.Team.class&#125;) private Integer number;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot/"},{"name":"SpringBoot项目必备","slug":"SpringBoot项目必备","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%85%E5%A4%87/"},{"name":"SpringBoot参数校验","slug":"SpringBoot参数校验","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"RestControllerAdvice","slug":"后端/springboot/RestControllerAdvice","date":"2023-12-18T01:07:28.000Z","updated":"2024-01-18T00:35:49.335Z","comments":true,"path":"2023/12/18/后端/springboot/RestControllerAdvice/","link":"","permalink":"https://aaajqhaaa.github.io/2023/12/18/%E5%90%8E%E7%AB%AF/springboot/RestControllerAdvice/","excerpt":"","text":"@RestControllerAdvice状态码enum类12345678910111213141516171819202122232425262728293031public enum ResultCode &#123; SUCCESS(200,&quot;操作成功!&quot;), FAILURE(201,&quot;操作失败&quot;), /**系统相关的错误码：5开头**/ ERROR(500,&quot;系统异常，请稍后重试&quot;), /**参数相关的错误码：1开头**/ PARAM_ERROR(1000,&quot;参数异常&quot;), /**权限相关的错误码：2开头**/ INVALID_TOKEN(2001,&quot;访问令牌不合法&quot;), ACCESS_DENIED(2002,&quot;没有权限访问该资源&quot;), USERNAME_OR_PASSWORD_ERROR(2003,&quot;用户名或密码错误&quot;); private final int code; private final String message; ResultCode(int code, String message)&#123; this.code = code; this.message = message; &#125; public int getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125;&#125; 统一返回值类1234567891011121314151617181920212223242526272829303132333435363738394041@Datapublic class Result&lt;T&gt; implements Serializable &#123; @Serial private static final long serialVersionUID = 1L; private Integer code; private String message; private T data; public Result(Integer code,String message)&#123; this.code = code; this.message = message; &#125; public Result(Integer code,String message,T data)&#123; this(code,message); this.data = data; &#125; public static &lt;T&gt; Result&lt;T&gt; success()&#123; return new Result&lt;&gt;(ResultCode.SUCCESS.getCode(),ResultCode.SUCCESS.getMessage()); &#125; public static &lt;T&gt; Result&lt;T&gt; success(T data)&#123; return new Result&lt;&gt;(ResultCode.SUCCESS.getCode(),ResultCode.SUCCESS.getMessage(),data); &#125; public static &lt;T&gt; Result&lt;T&gt; fail()&#123; return new Result&lt;&gt;(ResultCode.FAILURE.getCode(),ResultCode.FAILURE.getMessage()); &#125; public static &lt;T&gt; Result&lt;T&gt; fail(Integer code,String message)&#123; return new Result&lt;&gt;(code,message); &#125; public static &lt;T&gt; Result&lt;T&gt; error()&#123; return new Result&lt;&gt;(ResultCode.ERROR.getCode(),ResultCode.ERROR.getMessage()); &#125;&#125; 自定义运行时异常类123456789101112131415161718192021222324252627public class CustomException extends RuntimeException&#123; protected Integer code; protected String message; public CustomException(Integer code,String message,Throwable e) &#123; super(message,e); this.code = code; this.message = message; &#125; public CustomException(Integer code,String message)&#123; this(code,message,null); &#125; public void setCode(Integer code)&#123; this.code = code; &#125; public void setMessage(String message)&#123; this.message = message; &#125; public Integer getCode()&#123; return this.code; &#125;&#125; 全局异常处理类123456789101112131415161718192021222324@Slf4j@RestControllerAdvicepublic class GlobalException &#123; /** * 自定义异常处理 * @param e * @return */ @ExceptionHandler(value = CustomException.class) public Result&lt;Void&gt; customExceptionHandler(CustomException e) &#123; return Result.fail(e.getCode(),e.getMessage()); &#125; /** * 其他异常处理 * @param e * @return */ @ExceptionHandler(Exception.class) public Result&lt;Void&gt; exceptionHandler(Exception e) &#123; log.error(&quot;全局异常信息 ex=&#123;&#125;&quot;, e.getMessage(), e); return Result.error(); &#125;&#125; 示例1234@GetMapping(&quot;/test&quot;)public Result&lt;String&gt; test()&#123; throw new CustomException(ResultCode.USERNAME_OR_PASSWORD_ERROR.getCode(),ResultCode.USERNAME_OR_PASSWORD_ERROR.getMessage());&#125;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot/"},{"name":"SpringBoot项目必备","slug":"SpringBoot项目必备","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%85%E5%A4%87/"},{"name":"全局异常处理","slug":"全局异常处理","permalink":"https://aaajqhaaa.github.io/tags/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"统一响应","slug":"统一响应","permalink":"https://aaajqhaaa.github.io/tags/%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94/"}],"keywords":[]},{"title":"mediasoup","slug":"前端/mediasoup/mediasoup","date":"2023-12-13T08:48:32.000Z","updated":"2024-01-18T00:35:49.327Z","comments":true,"path":"2023/12/13/前端/mediasoup/mediasoup/","link":"","permalink":"https://aaajqhaaa.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/mediasoup/mediasoup/","excerpt":"","text":"mediasoup mediasoup：C++ SFU和服务器端Node.js模块。 mediasoup-client：客户端JavaScript库。 libmediasoupclient：基于libwebrtc的C++库。 mediasoup-client-aiortc：aiortc Python库的处理程序。适用于构建Node.js应用程序，这些应用程序使用WebRTC连接到媒体汤服务器，并与之交换真实的音频、视频和DataChannel消息。 mediasoup-demo：演示应用程序的源代码。 mediasoup-broadcaster-demo：基于libmediasoupclient的C++应用程序，将系统麦克风和网络摄像头生成到mediasoup演示中。 mediasoup-website：项目网站 https://mediasoup.org","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"mediasoup","slug":"mediasoup","permalink":"https://aaajqhaaa.github.io/tags/mediasoup/"},{"name":"webrtc","slug":"webrtc","permalink":"https://aaajqhaaa.github.io/tags/webrtc/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Node","slug":"前端/node/Node","date":"2023-12-13T08:25:41.000Z","updated":"2024-01-18T00:35:49.328Z","comments":true,"path":"2023/12/13/前端/node/Node/","link":"","permalink":"https://aaajqhaaa.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/node/Node/","excerpt":"","text":"nodeJS node -v","categories":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://aaajqhaaa.github.io/tags/node/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://aaajqhaaa.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Spring Bean注入","slug":"后端/springboot/bean_inject","date":"2023-12-01T04:44:49.000Z","updated":"2024-01-18T00:35:49.335Z","comments":true,"path":"2023/12/01/后端/springboot/bean_inject/","link":"","permalink":"https://aaajqhaaa.github.io/2023/12/01/%E5%90%8E%E7%AB%AF/springboot/bean_inject/","excerpt":"","text":"spring bean注入 @Resource：【javax.annotation.Resource】【注入可变的依赖】【作用在字段、方法和构造函数】【可根据名称显示匹配注入】【没找到抛异常】 @Autowired：【org.springframework.beans.factory.annotation.Autowired】【注入可变的依赖】【作用在字段、方法和构造函数】【没找到为null】 private final：【Spring Boot中使用构造函数注入】【注入不可变的依赖，确保字段的安全性和线程安全性】","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot/"},{"name":"Bean注入","slug":"Bean注入","permalink":"https://aaajqhaaa.github.io/tags/Bean%E6%B3%A8%E5%85%A5/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"onlyOfficeSpringBoot","slug":"其他/onlyOfficeSpringBoot","date":"2023-11-16T05:45:27.000Z","updated":"2024-01-18T00:35:49.309Z","comments":true,"path":"2023/11/16/其他/onlyOfficeSpringBoot/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/16/%E5%85%B6%E4%BB%96/onlyOfficeSpringBoot/","excerpt":"","text":"类分析 Thymeleaf：https://blog.csdn.net/SoulNone/article/details/127572997 JPA：https://blog.csdn.net/zdwzzu2006/article/details/131751921 H2：https://blog.csdn.net/qq_29645505/article/details/97697093 JSON.simple：https://blog.csdn.net/fireroll/article/details/48708241 Gson：https://zhuanlan.zhihu.com/p/451745696 JWT：https://www.cnblogs.com/hlkawa/p/13675792.html JackSon：https://blog.csdn.net/oschina_40730821/article/details/124025086 devtools：https://juejin.cn/post/7027647026510692360 devtools：https://blog.csdn.net/weixin_43701894/article/details/129921286 FileUtility、DefaultFileUtility 作用：文件工具类，用于文件名后缀判断文件类型，文件大小限制 String getFileExtension(String url);从URL获取文件扩展名（文件后缀） long getMaxFileSize();获取最大文件大小 List&lt;String&gt; getFileExts();获取所有支持的文件扩展名（所有后缀） String getFileNameWithoutExtension(String url);获取没有扩展名的文件名 List&lt;String&gt; getConvertExts();获取可转换的文件扩展名列表（所有后缀） FileStorageMutator、FileStoragePathBuilder、LocalFileStorage 文件存储Mutator，文件存储路径生成器，本地文件存储 String updateFile(String fileName, byte[] bytes);更新文件（字节数据更新到文件） void createMeta(String fileName, String uid, String uname);创建文件元信息 DocumentManager、DefaultDocumentManager- ServiceConverter、DefaultServiceConverterFileController 文件上传接口：【post】/upload 入参：文件、用户id 作用：用于用户自己上传一个文件，然后在线编辑 文件转换接口：【post】/converter 入参：Converter、用户id、语言 文件删除接口：【post】/delete 入参：Converter 文件下载接口：【post】/download 入参：Converter","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"onlyOffice","slug":"onlyOffice","permalink":"https://aaajqhaaa.github.io/tags/onlyOffice/"},{"name":"onlyOfficeSpringBoot","slug":"onlyOfficeSpringBoot","permalink":"https://aaajqhaaa.github.io/tags/onlyOfficeSpringBoot/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"注解@PostConstruct","slug":"后端/java/PostConstruct","date":"2023-11-10T08:40:43.000Z","updated":"2024-01-18T00:35:49.331Z","comments":true,"path":"2023/11/10/后端/java/PostConstruct/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/10/%E5%90%8E%E7%AB%AF/java/PostConstruct/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java注解","slug":"java注解","permalink":"https://aaajqhaaa.github.io/tags/java%E6%B3%A8%E8%A7%A3/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"日志","slug":"后端/springboot/Logs","date":"2023-11-10T05:48:51.000Z","updated":"2024-01-18T00:35:49.334Z","comments":true,"path":"2023/11/10/后端/springboot/Logs/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/10/%E5%90%8E%E7%AB%AF/springboot/Logs/","excerpt":"","text":"日志系统日志 程序执行时输出的debug、info、warn、error等不同级别的程序执行记录信息； 给程序员或运维看的，一般在出现异常问题的时候，可以通过系统日志中记录的关键参数信息和异常提示，快速排除故障。 操作日志 用户实际业务操作行为的记录，这些信息一般存储在数据库里，如什么时间哪个用户点了某个菜单、修改了哪个配置等这类业务操作行为，这些日志信息是给普通用户或系统管理员看到。 需求分析 1、记录用户的业务操作行为，记录的字段有：操作人、操作时间、操作功能、日志类型、操作内容描述、操作内容报文、操作前内容报文 2、提供一个可视化的页面，可以查询用户的业务操作行为，对重要操作回溯； 3、提供一定的管理功能，必要的时候可以对用户的误操作回滚； 反面实现 1、每个接口里都加一段记录业务操作日志的记录； 2、每个接口里都要捕获一下异常，记录异常业务操作日志； 硬编码实现的业务操作日志管理功能的问题 业务操作日志收集与业务逻辑耦合严重 代码重复，新开发的接口在完成业务逻辑后要织入一段业务操作日志保存的逻辑 已开发上线的接口，还要重新再修改织入业务操作日志保存的逻辑并测试，且每个接口需要织入的业务操作日志保存的逻辑是一样的 正面实现 方案一：javax.servlet.Filter（过滤器） 依赖于servlet容器 基于函数回调实现 拦截URL对应的请求request和响应response 链式传递请求request和响应response 结论：【适合处理请求内容和响应内容】【不适用细节记录】【获取不到特定方法，例如某个注解的标注方法】 方案二：org.springframework.web.servlet.HandlerInterceptor（拦截器） 依赖于SpringMVC框架 基于Java的反射机制实现（AOP思想） 拦截Controller中具体方法（请求处理程序） 用来做自定义预处理(带有禁止执行处理程序本身的选项)和自定义后处理，例如公共处理程序代码和授权检查 结论：【获取不到请求body的内容】【@ResponseBody标注的处理方法，获取不到响应数据】【可以获取特定方法，例如某个注解的标注方法】12345678910- 其他概念 - DispatcherServlet：【Spring的唯一Servlet】【使用HandlerMapping、HandlerAdapter进行请求分发】 - HandlerMapping：【处理器映射器】【请求找到Handler处理程序】 - HandlerAdapter：【处理器适配器】【执行Handler处理程序】- 为什么获取不到请求body？ - Servlet创建HttpServletRequest时不会获取getInputStream()，没有将流传递给拦截器 - Controller中能获取到是因为执行处理程序之前调用getInputStream()，将流传递过去了- 为什么这么设计？ - 设计上就是如此【提高效率、降低耦合度、提高灵活性】 - 解决：【1、自定义重写一个HttpServletRequestWrapper获取流参数】【2、自定义重写一个DispatcherServlet派发请求】 方案三：Spring AOP（切面） 对作用域没有限制，定义好切点 颗粒度更细：前置通知（@Before）、后置通知（@After）、返回后通知（@AfterReturning）、异常通知（@AfterThrowing）、环绕通知（@Around） 结论：【可以获取方法参数】【可以获取方法返回值】【可以修改返回值】 123456789101112131415161718192021222324252627282930313233343536373839package javax.servlet;import java.io.IOException;public interface Filter &#123; /** * 过滤器实例初始化（只调用一次） * * @param filterConfig 与正在初始化的过滤器实例相关联的配置信息 * * @throws ServletException 初始化失败抛异常 */ default void init(FilterConfig filterConfig) throws ServletException &#123;&#125; /** * 每次请求时，容器都会调用doFilter方法 * 此方法的典型实现将遵循以下模式: * 1。检查请求 * 2。修改请求对象，请求头 * 3。修改响应对象，响应头 * 4-1。使用FilterChain对象chain. dofilter()调用链中的下一个实体， * 4-2。或者不将请求、响应对传递给过滤器链中的下一个实体以阻止请求处理 * * @param request 要处理的请求 * @param response 与请求相关联的响应 * @param chain 链式调用，下一过滤器的访问 * * @throws IOException 如果在此过滤器处理请求期间发生I/O错误 * @throws ServletException 如果处理因任何其他原因失败 */ void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; /** * 由web容器调用，表示过滤器正在退出。 * 此方法可以来清理所有被占用的资源(例如，内存、文件句柄、线程)，并确保任何持久状态都与过滤器在内存中的当前状态同步。 */ default void destroy() &#123;&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package org.springframework.web.servlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.lang.Nullable;import org.springframework.web.method.HandlerMethod;/** * * 有关更多选项和详细信息，请参见&#123;@code org.springframework.web.servlet.AsyncHandlerInterceptor&#125; * 通常，每个HandlerMapping bean定义一个拦截器链，共享其粒度。 * 为了能够将某个拦截器链应用到一组处理程序，需要通过一个HandlerMapping bean映射所需的处理程序。拦截器本身在应用程序上下文中被定义为bean，由映射bean定义通过其“interceptors”属性引用。 */public interface HandlerInterceptor &#123; /** * 在【HandlerAdapter调用处理程序】之前调用 * 可以终止 * 作用：登录验证（判断用户是否登录）权限验证：判断用户是否有权访问资源（校验token） * @param request 当前HTTP请求 * @param response 当前HTTP响应 * @param handler 选择要执行的处理程序，用于类型或实例计算 * @return &#123;@code true&#125; 如果执行链应该继续下一个拦截器或处理程序本身。否则，DispatcherServlet假定这个拦截器已经处理了响应本身。 */ default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; /** * 在【HandlerAdapter调用处理程序】之后调用 * 在【DispatcherServlet呈现视图】之前调用 * 每个拦截器都可以对执行进行后处理，以执行链的相反顺序执行 * 作用：将Controller层返回来的参数进行一些修改，在ModelAndView中 * @param request 当前HTTP请求 * @param response 当前HTTP响应 * @param handler 启动异步执行的处理程序(或&#123;@link HandlerMethod&#125;)，用于类型或实例检查 * @param modelAndView 处理程序返回的&#123;@code ModelAndView&#125;(也可以是&#123;@code null&#125;) */ default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;&#125; /** * 在【DispatcherServlet呈现视图】之后调用 * 进行适当的资源清理。 * 作用：例如登录的时候，我们经常把用户信息放到ThreadLocal中，为了防止内存泄漏，就需要将其remove掉，该操作就是在这里执行的 * 注意: 只有&#123;@code preHandle&#125;方法成功完成并返回&#123;@code true&#125;时才会被调用! * 与&#123;@code postHandle&#125;方法一样，该方法将以相反的顺序在链中的每个拦截器上被调用，因此第一个拦截器将是最后一个被调用的。 * * @param request 当前HTTP请求 * @param response 当前HTTP响应 * @param handler 启动异步执行的处理程序(或&#123;@link HandlerMethod&#125;)，用于类型或实例检查 */ default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;&#125;&#125; Spring AOP（切面）实现 依赖 12345&lt;!-- aop依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 切入点：自定义注解 123456789101112@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface JQHLog &#123; /** * 功能名称 */ String name() default &quot;&quot;; /** * 功能描述 */ String descript() default &quot;&quot;;&#125; 切面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129@Component@Aspect@Slf4jpublic class LogAspect implements Ordered &#123; /** * 前后端不分离架构，如果统一异常处理执行顺序在@AfterThrowing之前，会出现@AfterThrowing中不执行情况。 * 前后端分离架构不会出现此问题。 * 解决：实现Ordered接口，并重写getOrder()方法，使其返回值为1，返回值越小，执行的顺序越靠前，使其执行顺序优先于全部异常处理类。 */ @Override public int getOrder() &#123; return 1; &#125; /** * 定义切点：自定义注解 */ @Pointcut(&quot;@annotation(com.example.uidemo.log.JQHLog)&quot;) public void pointcut()&#123;&#125; /** * 目标方法执行之前 * @param joinPoint */ @Before(&quot;pointcut()&quot;) public void before(JoinPoint joinPoint)&#123; print(&quot;@Before&quot;, joinPoint); &#125; /** * 目标方法执行之后 * @param joinPoint */ @After(&quot;pointcut()&quot;) public void after(JoinPoint joinPoint)&#123; print(&quot;@After&quot;, joinPoint); &#125; /** * 目标方法返回执行结果之后（可以修改返回值） * @param joinPoint */ @AfterReturning(pointcut = &quot;pointcut()&quot;, returning = &quot;obj&quot;) public Object afterReturning(JoinPoint joinPoint, Object obj)&#123; print(&quot;@AfterReturning&quot;, joinPoint); return obj; &#125; /** * 目标方法抛出异常后 * @param joinPoint * @param e */ @AfterThrowing(value = &quot;pointcut()&quot;,throwing = &quot;e&quot;) public void afterThrowing(JoinPoint joinPoint,Exception e)&#123; print(&quot;@AfterThrowing&quot;, joinPoint); &#125; /** * 可以使用ProceedingJoinPoint joinPoint，获取目标对象，通过动态代理，代理目标类执行，在目标对象执行前后均可 * @param joinPoint * @throws Throwable */ @Around(&quot;pointcut()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; Object result = null; long beginTime = System.currentTimeMillis(); try &#123; result = joinPoint.proceed(); &#125; catch (Throwable e) &#123; throw new RuntimeException(&quot;执行失败&quot;,e); &#125; // 执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); // 获取方法注解 JQHLog logAnnotation = method.getAnnotation(JQHLog.class); // 注解名 String name = logAnnotation.name(); // 注解描述 String descript = logAnnotation.descript(); // 类名 String className = joinPoint.getTarget().getClass().getName(); // 方法名 String methodName = joinPoint.getSignature().getName(); // 请求的方法参数值 Object[] args = joinPoint.getArgs(); // 请求的方法参数名称 LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer(); String[] paramNames = u.getParameterNames(method); if (args != null &amp;&amp; paramNames != null) &#123; String params = &quot;&quot;; for (int i = 0; i &lt; args.length; i++) &#123; params += &quot; &quot; + paramNames[i] + &quot;: &quot; + args[i]; &#125; &#125; // 请求request参数 ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes(); // 请求ip String ip = attributes.getRequest().getRemoteHost(); // 请求路径 String requestURI = attributes.getRequest().getRequestURI(); // 请求方法 String requestMethod = attributes.getRequest().getMethod(); print(&quot;@Around&quot;, joinPoint); return result; &#125; /** * 打印基本信息 * @param msg * @param joinPoint */ public void print(String msg, JoinPoint joinPoint)&#123; Map info = new HashMap&lt;&gt;(); info.put(&quot;类名&quot;, joinPoint.getTarget().getClass().getName()); info.put(&quot;方法名&quot;, joinPoint.getSignature().getName()); // 请求参数 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes != null)&#123; info.put(&quot;请求ip&quot;, attributes.getRequest().getRemoteHost()); info.put(&quot;请求路径&quot;, attributes.getRequest().getRequestURI()); info.put(&quot;请求方法&quot;, attributes.getRequest().getMethod()); &#125; log.info(&quot;&#123;&#125;：&#123;&#125;&quot;, msg, info.toString()); &#125;&#125; 可能遇到的问题 单个类内的方法调用是不能够进入切面中的（@Transactional也有这问题） 原因：内部方法调用时并未使用代理对象进行代理 解决方法：内部调用时，拿到代理对象调用（用AopContext类来获取当前类的代理对象，前提：启动类上加@EnableAspectJAutoProxy(exposeProxy = true)）1234567/** * 强制获取代理对象，必须开启exposeProxy配置，否则获取不到当前代理对象 * @EnableAspectJAutoProxy(exposeProxy = true) */private XXXImpl getThis() &#123; return AopContext.currentProxy() != null ? (XXXImpl) AopContext.currentProxy() : this;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot/"},{"name":"SpringBoot项目必备","slug":"SpringBoot项目必备","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%85%E5%A4%87/"},{"name":"SpringBoot日志","slug":"SpringBoot日志","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot%E6%97%A5%E5%BF%97/"},{"name":"系统日志","slug":"系统日志","permalink":"https://aaajqhaaa.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97/"},{"name":"操作日志","slug":"操作日志","permalink":"https://aaajqhaaa.github.io/tags/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"Local类","slug":"后端/java/Local","date":"2023-11-09T07:03:28.000Z","updated":"2024-01-18T00:35:49.331Z","comments":true,"path":"2023/11/09/后端/java/Local/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/09/%E5%90%8E%E7%AB%AF/java/Local/","excerpt":"","text":"作用 不同国家的语言、文字、数字、日期都有不同显示 Local可用根据系统语言对其进行显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import java.text.NumberFormat;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.time.format.FormatStyle;import java.util.Locale;import java.util.Set;public class Test &#123; public static void main(String[] args) &#123; /** * 获取当前的语言和国家 */ Locale defaultLocal = Locale.getDefault(); String country = defaultLocal.getCountry();// CN String displayCountry = defaultLocal.getDisplayCountry();// 中国 String displayCountry1 = defaultLocal.getDisplayCountry(Locale.ENGLISH);// China String iso3Country = defaultLocal.getISO3Country();// CHN String language = defaultLocal.getLanguage();// zh String iso3Language = defaultLocal.getISO3Language();// zho String displayLanguage = defaultLocal.getDisplayLanguage();// 中文 String displayLanguage1 = defaultLocal.getDisplayLanguage(Locale.ENGLISH);// Chinese String displayName = defaultLocal.getDisplayName();// 中文 (中国) /** * 获取所有的语言及国家 */ Locale[] locales = Locale.getAvailableLocales(); /** * 获取所有国家 */ String[] countries = Locale.getISOCountries(); /** * 获取所有的语言 */ String[] languages = Locale.getISOLanguages(); /** * 获取某个国家对应的标签 */ String s = Locale.US.toLanguageTag();// en-US /** * 获取某个国家对应的语言 */ String s2 = Locale.ENGLISH.toLanguageTag();// en /** * 构建Local */ Locale locale = Locale.forLanguageTag(&quot;en-US&quot;);// 使用标签生成Local Locale locale2 = new Locale(&quot;en&quot;);// 构造函数生成Local Locale locale3 = new Locale(&quot;en&quot;, &quot;US&quot;);// 构造函数生成Local Locale locale4 = Locale.CHINA; /** * 数字格式化 */ NumberFormat numberInstance = NumberFormat.getNumberInstance(Locale.CHINA); String format = numberInstance.format(123456.78);// 123,456.78 /** * 货币格式化 */ NumberFormat currencyInstance = NumberFormat.getCurrencyInstance(Locale.CHINA); String format1 = currencyInstance.format(123456.78);// ￥123,456.78 /** * 百分比格式化 */ NumberFormat percentInstance = NumberFormat.getPercentInstance(Locale.CHINA); String format2 = percentInstance.format(0.2);// /** * 时间日期格式化 * - 月份和星期的数字应该用本地语言 * - 年月日的顺序符合本地习惯 * - 公历可能并不是本地首选表示方法 * - 需考虑本地的时区 */ LocalDate localDate = LocalDate.now();// 2023-11-09 String format3 = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).format(localDate);// 23-11-9 String format31 = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).withLocale(Locale.ENGLISH).format(localDate);// 11/9/23 String format4 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM).format(localDate);// 2023-11-9 String format41 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM).withLocale(Locale.ENGLISH).format(localDate);// Nov 9, 2023 String format5 = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).format(localDate);// 2023年11月9日 String format51 = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).withLocale(Locale.ENGLISH).format(localDate);// November 9, 2023 String format6 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL).format(localDate);// 2023年11月9日 星期四 String format61 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL).withLocale(Locale.ENGLISH).format(localDate);// Thursday, November 9, 2023 LocalTime localTime = LocalTime.now();// 16:31:18.072 String format7 = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).format(localTime);// 下午4:29 String format71 = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).withLocale(Locale.ENGLISH).format(localTime);// 4:29 PM String format8 = DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM).format(localTime);// 16:29:49 String format81 = DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM).withLocale(Locale.ENGLISH).format(localTime);// 4:29:49 PM String format9 = DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG).format(localTime);// 下午04时29分49秒// String format91 = DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG).withLocale(Locale.ENGLISH).format(localTime);//// String format10 = DateTimeFormatter.ofLocalizedTime(FormatStyle.FULL).format(localTime);//// String format101 = DateTimeFormatter.ofLocalizedTime(FormatStyle.FULL).withLocale(Locale.ENGLISH).format(localTime);// LocalDateTime localDateTime = LocalDateTime.now();// 2023-11-09T16:31:18.072 String format11 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).format(localDateTime);// 23-11-9 下午4:31 String format111 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).withLocale(Locale.ENGLISH).format(localDateTime);// 11/9/23 4:31 PM String format12 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(localDateTime);// 2023-11-9 16:31:18 String format121 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).withLocale(Locale.ENGLISH).format(localDateTime);// Nov 9, 2023 4:31:18 PM String format13 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG).format(localDateTime);// 2023年11月9日 下午04时31分18秒// String format131 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG).withLocale(Locale.ENGLISH).format(localDateTime);//// String format14 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL).format(localDateTime);//// String format141 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL).withLocale(Locale.ENGLISH).format(localDateTime);// ZonedDateTime zonedDateTime = ZonedDateTime.now();// 2023-11-09T16:31:54.917+08:00[GMT+08:00] String format15 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).format(zonedDateTime);// 23-11-9 下午4:31 String format151 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).withLocale(Locale.ENGLISH).format(zonedDateTime);// 11/9/23 4:31 PM String format16 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(zonedDateTime);// 2023-11-9 16:31:54 String format161 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).withLocale(Locale.ENGLISH).format(zonedDateTime);// Nov 9, 2023 4:31:54 PM String format17 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG).format(zonedDateTime);// 2023年11月9日 下午04时31分54秒 String format171 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG).withLocale(Locale.ENGLISH).format(zonedDateTime);// November 9, 2023 4:31:54 PM GMT+08:00 String format18 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL).format(zonedDateTime);// 2023年11月9日 星期四 下午04时31分54秒 GMT+08:00 String format181 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL).withLocale(Locale.ENGLISH).format(zonedDateTime);// Thursday, November 9, 2023 4:31:54 PM GMT+08:00 &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java.util类","slug":"java-util类","permalink":"https://aaajqhaaa.github.io/tags/java-util%E7%B1%BB/"},{"name":"java国际化","slug":"java国际化","permalink":"https://aaajqhaaa.github.io/tags/java%E5%9B%BD%E9%99%85%E5%8C%96/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"注解@Builder","slug":"后端/lombok/Builder","date":"2023-11-09T02:52:09.000Z","updated":"2024-01-18T00:35:49.332Z","comments":true,"path":"2023/11/09/后端/lombok/Builder/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/09/%E5%90%8E%E7%AB%AF/lombok/Builder/","excerpt":"","text":"作用 它作用于类，将其变成建造者模式，可以以链的形式调用12345678910111213141516171819202122232425262728293031323334353637package lombok;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.SOURCE)public @interface Builder &#123; String builderMethodName() default &quot;builder&quot;; String buildMethodName() default &quot;build&quot;; String builderClassName() default &quot;&quot;; boolean toBuilder() default false; AccessLevel access() default AccessLevel.PUBLIC; String setterPrefix() default &quot;&quot;; @Target(&#123;ElementType.FIELD&#125;) @Retention(RetentionPolicy.SOURCE) public @interface Default &#123; &#125; @Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;) @Retention(RetentionPolicy.SOURCE) public @interface ObtainVia &#123; String field() default &quot;&quot;; String method() default &quot;&quot;; boolean isStatic() default false; &#125;&#125; 原理： 编译时创建一个内部静态类，有和实体类相同的属性（构造器） 构造器：所有属性的set方法，返回值是this（链式调用）","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"lombok注解","slug":"lombok注解","permalink":"https://aaajqhaaa.github.io/tags/lombok%E6%B3%A8%E8%A7%A3/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"注解@SneakyThrows","slug":"后端/lombok/SneakyThrows","date":"2023-11-08T06:40:20.000Z","updated":"2024-01-18T00:35:49.333Z","comments":true,"path":"2023/11/08/后端/lombok/SneakyThrows/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/08/%E5%90%8E%E7%AB%AF/lombok/SneakyThrows/","excerpt":"","text":"作用 @SneakyThrows注解为代码生成一个tr&#123;&#125;catch&#123;&#125;块,并把异常向上抛出来 作用在方法、构造方法上123456789101112package lombok;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SneakyThrows &#123; Class&lt;? extends Throwable&gt;[] value() default &#123;Throwable.class&#125;;&#125; java中常见的异常有两种： Exception即非运行时异常(编译异常) RuntimeException即运行时异常 正常情况：编译异常需要处理（增加tr&#123;&#125;catch&#123;&#125;或者方法抛出去）1234567public void hhh(User user)&#123; try &#123; int userId = user.getId(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125; @SneakyThrows注解会自动为代码生成一个上面的tr&#123;&#125;catch&#123;&#125;块,并把异常向上抛出来（编辑器不会报错）1234@SneakyThrowspublic void hhh(User user)&#123; int userId = user.getId();&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"lombok注解","slug":"lombok注解","permalink":"https://aaajqhaaa.github.io/tags/lombok%E6%B3%A8%E8%A7%A3/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"注解@CrossOrigin","slug":"后端/springboot/CrossOrigin","date":"2023-11-08T06:40:20.000Z","updated":"2024-01-18T00:35:49.333Z","comments":true,"path":"2023/11/08/后端/springboot/CrossOrigin/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/08/%E5%90%8E%E7%AB%AF/springboot/CrossOrigin/","excerpt":"","text":"作用 原理：利用spring的拦截器实现往响应头里添加Access-Control-Allow-Origin等响应头信息 用在类、方法上1234567891011121314151617181920212223242526272829303132333435363738394041424344package org.springframework.web.bind.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CrossOrigin &#123; /** @deprecated */ @Deprecated String[] DEFAULT_ORIGINS = new String[]&#123;&quot;*&quot;&#125;; /** @deprecated */ @Deprecated String[] DEFAULT_ALLOWED_HEADERS = new String[]&#123;&quot;*&quot;&#125;; /** @deprecated */ @Deprecated boolean DEFAULT_ALLOW_CREDENTIALS = false; /** @deprecated */ @Deprecated long DEFAULT_MAX_AGE = 1800L; @AliasFor(&quot;origins&quot;) String[] value() default &#123;&#125;; @AliasFor(&quot;value&quot;) String[] origins() default &#123;&#125;; String[] originPatterns() default &#123;&#125;; String[] allowedHeaders() default &#123;&#125;; String[] exposedHeaders() default &#123;&#125;; RequestMethod[] methods() default &#123;&#125;; String allowCredentials() default &quot;&quot;; long maxAge() default -1L;&#125; 概念 浏览器的同源策略限制：是一个重要的安全策略 同源（同一个域）：URL的协议、主机 (域名) 、端口都一致 跨域：URL的协议、主机 (域名) 、端口有一个不同 解决方案： JSONP：通过script标签没有跨域限制的特性，进行资源的请求和获取（需要目标服务器进行配合，且仅支持get请求） CORS：Cross-Origin Resource sharing（跨域资源共享），是一种基于HTTP头的机制，服务端在响应头里添加Access-Control-Allow-Origin等响应头信息标记哪些域可以访问 服务器代理：同源策略主要是限制浏览器和服务器之间的请求，服务器与服务器之间并不存在跨域","categories":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot/"},{"name":"SpringBoot注解","slug":"SpringBoot注解","permalink":"https://aaajqhaaa.github.io/tags/SpringBoot%E6%B3%A8%E8%A7%A3/"},{"name":"跨域","slug":"跨域","permalink":"https://aaajqhaaa.github.io/tags/%E8%B7%A8%E5%9F%9F/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://aaajqhaaa.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"OnlyOffice Document Server教程","slug":"其他/onlyOfficeDocumentServer","date":"2023-11-03T07:58:33.000Z","updated":"2024-01-18T00:35:49.308Z","comments":true,"path":"2023/11/03/其他/onlyOfficeDocumentServer/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/03/%E5%85%B6%E4%BB%96/onlyOfficeDocumentServer/","excerpt":"","text":"OnlyOffice Document Server教程 官网教程地址 开始基本概念 OnlyOffice是一个开源办公套件，包括文本文档、电子表格、演示文稿和可填写表格的编辑器。它提供了以下功能： 创建、编辑和查看文本文档、电子表格、演示文稿和可填写表格； 多人实时协作处理文件。 OnlyOffice还支持WOPI协议，该协议用于将您的应用程序与在线office集成。 OnlyOffice API用于让开发人员将OnlyOffice文档/电子表格/演示文稿编辑器集成到自己的网站中，并设置和管理编辑器。 API JavaScript文件通常可以在以下编辑器文件夹中找到： https://documentserver/web-apps/apps/api/documents/api.js 其中documentserver是Document server的服务器的地址。 要嵌入编辑器的目标HTML文件需要有一个占位符div标记，其中将传递有关编辑器参数的所有信息：12&lt;div id=&quot;placeholder&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://documentserver/web-apps/apps/api/documents/api.js&quot;&gt;&lt;/script&gt; 包含可变参数的页面代码如下所示：1var docEditor = new DocsAPI.DocEditor(&quot;placeholder&quot;, config); 其中config是一个对象：123456789101112config = &#123; &quot;document&quot;: &#123; &quot;fileType&quot;: &quot;docx&quot;, &quot;key&quot;: &quot;Khirz6zTPdfd7&quot;, &quot;title&quot;: &quot;Example Document Title.docx&quot;, &quot;url&quot;: &quot;https://example.com/url-to-example-document.docx&quot; &#125;, &quot;documentType&quot;: &quot;word&quot;, &quot;editorConfig&quot;: &#123; &quot;callbackUrl&quot;: &quot;https://example.com/url-to-callback.ashx&quot; &#125;&#125;; 其中example.com是文档管理和存储服务器地址。请参阅如何工作部分，以了解有关DocumentServer服务客户端-服务器交互的更多信息。 一切ok则docEditor对象可以用来调用文档编辑器方法。 上面的示例包括正确启动所需的所有参数。 还可以更改其他非强制性参数，以实现其他功能（更改文档的访问权限、显示文档的不同信息等）。请参阅高级参数部分，了解这些参数是什么以及如何更改它们。 为了防止替换重要参数，请以令牌的形式向请求添加加密签名。 获取OnlyOffice文档 可用于Windows、Linux和Docker。 要在本地服务器上安装，请按照OnlyOffice帮助中心中的说明进行操作： Windows安装 Linux安装 Docker安装 在使用API文档之前，如有必要，建议进行以下设置： 配置文件中配置服务器设置； 切换到HTTPS协议，以便使用SSL证书进行安全连接； 添加额外的字体，以增强编辑器的工作； 为应用程序界面添加您自己的颜色主题。 立即尝试 您可以打开各种文件类型进行编辑、查看、共同编辑、审查或查看重新命名的工作原理。 点击&lt;/&gt;按钮查看相应的示例源代码。 特定于语言的例子 各个语言的demo","categories":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"OnlyOffice","slug":"OnlyOffice","permalink":"https://aaajqhaaa.github.io/tags/OnlyOffice/"},{"name":"OnlyOffice Document Server","slug":"OnlyOffice-Document-Server","permalink":"https://aaajqhaaa.github.io/tags/OnlyOffice-Document-Server/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"OnlyOffice介绍及docker部署Document Server","slug":"其他/onlyoffice","date":"2023-11-02T05:27:26.000Z","updated":"2024-01-18T00:35:49.309Z","comments":true,"path":"2023/11/02/其他/onlyoffice/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/02/%E5%85%B6%E4%BB%96/onlyoffice/","excerpt":"","text":"描述和功能描述 OnlyOffice是一个多端协同的 Office 办公套件，结合了文本文档、电子表格、演示文稿和表单的编辑器。 后端：JavaScript语言和Node.js构建服务器端脚本 前端：使用HTML5呈现文档元素。 编辑器的技术基础是HTML5 Canvas。画布是一个包含不同绘图元素的容器，如线条、形状、图形和框架。HTML结构中的每个对象都是独立处理的，而画布结构的其余部分不受该特定对象的操作的影响。这有助于保持高精度的显示，使内容浏览器和操作系统不可知，并在查看、编辑或打印文档时提供平等的文档呈现。 核心格式组是OOXML，它使套件与DOCX、XLSX和PPTX文件完全兼容，而其他格式则通过内部转换进行处理。 具有实时协同编辑、评论、在线聊天、版本历史记录、跟踪更改和文档比较等协作工具，并支持各种类型的共享权限，包括完全访问、仅查看、评论、审阅、填写表单和自定义筛选。 可以使用基于API通信或WOPI协议的集成应用程序在第三方环境中集成。 可以使用不同的方法在客户端的体系结构上进行部署，包括Windows和Linux服务器安装选项、Docker、Pod 结构 服务体系结构在OnlyOffice文档部署模型的数据安全性、性能和灵活性方面发挥着至关重要的作用。 客户端：浏览器中调用一个完整的文档编辑器应用程序，将大部分流程负载转移到客户端 服务器端只处理保存、传输文件更改和拼写检查等过程。 体系结构中的每个服务都可以单独托管在一个集群中，这还增加了容错能力，并允许根据环境构建自定义服务映射。 服务架构如下： 这样的架构设计使得一台32GB RAM的8核机器足以容纳1000个同时编辑的文档，假设每4秒对所有文档进行一次更改（1000个连接每秒250次更改）。 编辑功能支持的电子文件格式支持以下类型的格式用于查看和编辑： 查看 编辑 下载 文本文档 DOC, DOCX, DOTX, FB2, ODT, OTT, RTF, TXT, PDF, PDF&#x2F;A, HTML, EPUB, XPS, DjVu, XML, DOCXF, OFORM DOC, DOCX, DOTX, FB2, ODT, OTT, RTF, TXT, HTML, EPUB, XML, DOCXF, OFORM DOCX, DOTX, FB2, ODT, OTT, RTF, TXT, PDF, PDF&#x2F;A, HTML, EPUB, DOCXF, OFORM 电子表格 XLS, XLSX, XLTX, ODS,OTS, CSV XLS, XLSX, XLTX, ODS,OTS, CSV XLSX, XLTX, ODS,OTS, CSV, PDF,PDF&#x2F;A 演讲 PPT, PPTX, POTX, ODP, OTP, PPSX PPT, PPTX, POTX, ODP, OTP PPTX, POTX, ODP, OTP, PDF, PDF&#x2F;A, PNG, JPG 协作功能 允许在集成平台内的任意数量的用户之间协作编辑文档。 由于OnlyOffice Docs的架构意味着编辑器的客户端性能，在同一服务器上处理同一文档时，每个用户都可以独立于所有其他用户激活任何功能或选择任何模式。 这显著改进了许多方面的工作，包括使用撤消和重做命令独立恢复操作。这种方法还最小化了服务器负载，使设置变得轻量级。 协作功能包括： 灵活的共享权限：仅查看、完全访问、审阅、注释、填写表单、自定义筛选器。 两种协同编辑模式：快速（实时）和严格（段落锁定） 跟踪变化； 评论； 在评论中提及用户； 内置聊天； 版本和修订控制（版本历史）。 通过独立使用所有功能和协作模式，来自不同设备和客户端（包括网络套件、桌面和移动应用程序）的大量用户之间可以进行协作。 尽管大多数操作都是在OnlyOffice文档（文档服务器）中执行的，但有些功能在集成中依赖于与用户管理系统的通信。版本历史记录和提及等功能的可用性目前在每个集成中都有所不同。 数据安全 在设计上是安全的，这得益于自托管的部署模型。此外，在任何基础结构中存储和编辑文件时，它都提供了多种保护数据的功能： 为了保护流量，OnlyOffice使用HTTPS运行，而文档编辑连接则使用JWT进行额外保护。 共享中提供灵活的权限：使用完全访问、只读、评论、审阅或填写表单权限，允许或不允许修改电子表格中的筛选器，如果您愿意，还可以限制下载、复制和打印。 您还可以应用水印，以避免未经授权重新分发您的内容。 文件加密可用于文件和电子表格，包括保护整个工作簿和电子表格中的单独表格。 OnlyOffice具有内置功能，可帮助企业遵守HIPAA和欧盟隐私法规。 接口定制可以自定义OnlyOffice文档的界面，以增强使用套件时的体验。 选项 说明 界面主题 可以将界面主题分别设置为暗、亮和经典灯光。在某些集成中，可以在管理级别控制主题设置。 界面和文档缩放 编辑器支持100%、125%、150%、175%和200%的自动缩放。 手动文档缩放选项的范围从50%到200%。 工具栏、状态栏和标尺 可以隐藏主工具栏、状态栏和标尺以展开工作区域。 工具栏布局* 在设置中，可以在完整和紧凑的工具栏布局之间切换，并更改选项卡的颜色。 附加选项（适用于开发人员） 脚本级配置允许调整按钮和命令、公司和联系人信息、徽标等的显示。 整合机制通过基于API的连接器进行集成 基于API的集成是将OnlyOffice文档连接到文件存储和共享环境的一种随意方式，包括同步和共享服务、内容管理系统（CMS）和学习管理系统（LMS）。目前大多数可用的连接器都是基于API的。 开放式API允许构建应用程序，以集成OnlyOffice独有的任何功能，或将自定义重新构建功能集成到连接的存储中，为用户提供完整的体验。 基于API的集成方案 OnlyOffice文档（文档服务器）与第三方服务的集成需要一个额外的应用程序，该应用程序将数据转换为兼容的格式。此角色由连接器扮演。OnlyOffice团队创建自己的官方连接器，并协助合作伙伴和第三方开发人员创建此类应用程序。 集成应用程序结构 通过基于API的集成提供的功能*： 功能 说明 支持格式 用于查看和编辑：DOCX、XLSX、PPTX、PPSX、OFORM、DOCXF 仅供查看：PDF、DJVU、TXT、CSV、ODT、ODS、ODP、DOC、XLS、PPT、PPS、EPUB、RTF、HTML、HTM、MHT、XPS 协作模式 在实时和段落锁定协同编辑模式之间切换。 自定义 为编辑器设置界面语言和主题、隐藏聊天菜单按钮、更改“关于”部分中的信息、界面自定义，如调整标题和工具栏、品牌、连接插件 基本功能 查看、编辑、共同编辑、移动查看和编辑、简化查看（嵌入式） 其他操作：方法 以所选格式下载文件、将文件标记为收藏夹、显示带有消息的工具提示 其他操作：事件 关闭编辑器、打开文件位置、将文件从查看模式切换到编辑模式、重命名文档、管理文档访问权限、打开版本历史记录、插入存储中的图像、邮件合并、与存储中的文档进行比较、在书签位置获取打开文件的链接、以所需格式保存文件、在评论中提及其他用户、创建新文档 安全 IP地址白名单、使用JWT验证请求和防止未经授权访问 文档权限 查看、编辑、审查（文本文件）、评论、填写表格、修改内容控件（文本文档）、修改过滤器（电子表格）、复制到剪贴板、下载、打印、重命名 局限性 编辑器中提供的所有功能都可以集成。 实战开发OnlyOffice社区版 文档服务器：Document Server 社区服务器：Community Server 邮件服务器：Mail Server docker部署文档服务器 【官网教程】 1、拉取镜像： 1docker pull onlyoffice/documentserver 2、启动容器： 1234567docker run -itd -p 9000:80 --restart=always -v D:\\workNew\\study\\onlyoffice\\DocumentServer\\logs:/var/log/onlyoffice # 日志数据-v D:\\workNew\\study\\onlyoffice\\DocumentServer\\data:/var/www/onlyoffice/Data # ssl证书-v D:\\workNew\\study\\onlyoffice\\DocumentServer\\lib:/var/lib/onlyoffice # 文件缓存数据-v D:\\workNew\\study\\onlyoffice\\DocumentServer\\db:/var/lib/postgresql # 数据库-e JWT_SECRET=my_jwt_secret # JWT密钥，不设置会自动生成，也可以关闭【-e JWT_ENABLED=false】onlyoffice/documentserver # 镜像名 进入容器：docker exec -it ID /bin/bash 启动所有的内置服务：supervisorctl restart all 退出容器：exit 访问：http://IP:9000/ 页面包括 开发文档 查看密钥：1docker exec ID /var/www/onlyoffice/documentserver/npm/json -f /etc/onlyoffice/documentserver/local.json &#x27;services.CoAuthoring.secret.session.string&#x27; 启动example服务：1docker exec ID sudo supervisorctl start ds:example 设置example服务自动启动：1docker exec ID sudo sed &#x27;s,autostart=false,autostart=true,&#x27; -i /etc/supervisor/conf.d/ds-example.conf 服务列表（都是通过pkg打包成可执行文件，摆脱node环境的依赖） ds:converter：转换器 ds:docservice：文档服务 ds:example：例子 ds:metrics 服务占用端口： nginx：80 rabbitmq：5672、25672、4369 postgres：5432 docservice: 8000 example：3000 example测试","categories":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"OnlyOffice","slug":"OnlyOffice","permalink":"https://aaajqhaaa.github.io/tags/OnlyOffice/"},{"name":"OnlyOffice Docker部署Document Server","slug":"OnlyOffice-Docker部署Document-Server","permalink":"https://aaajqhaaa.github.io/tags/OnlyOffice-Docker%E9%83%A8%E7%BD%B2Document-Server/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"hexo博客搭建","slug":"其他/hexo","date":"2023-10-31T16:00:00.000Z","updated":"2024-01-18T00:35:49.292Z","comments":true,"path":"2023/11/01/其他/hexo/","link":"","permalink":"https://aaajqhaaa.github.io/2023/11/01/%E5%85%B6%E4%BB%96/hexo/","excerpt":"","text":"什么是 Hexo？ 一个快速、简洁且高效的博客框架【Hexo中文官网】 本地环境 nodejs git 本地项目搭建 1、安装hexo客户端：npm install -g hexo-cli 2、新建一个文件夹：myblog 3、初始化hexo，在文件夹下执行：hexo init 目录结构 node_modules: 依赖包 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 4、启动运行：hexo server 5、访问http://localhost:4000/ 新增主题 官网选择需要的主题【主题选择网址】 我这里选择snippet 进入themes目录下把代码拉下来：git clone https://github.com/shenliyang/hexo-theme-snippet.git _config.yml文件中配置主题：theme: hexo-theme-snippet 重新启动运行：hexo server 每种主题有哪些配置可以看md文件，根据自己需求进行配置 写博客 新建分类：hexo new page &quot;categories&quot; 新建标签：hexo new page &quot;tags&quot; 新建文章：hexo new 文件名（会在_posts下生成md文件） 文件内容（前面是配置标题、时间、分类、标签，后面就可以写文章了）12345678910---title: 文件名date: 2023-11-02 10:41:01category: 哈哈tags: - xxx - hhh---# 标题1- 哈哈哈 md文件中如何插入图片等资源【官网资源配置】 我是建一个和md文件名相同的文件夹，然后将图片放下面 部署到github 教程：【官网教程】 1、新建一个github仓库，仓库名为账号名.github.io，新建md文件初始化main分支 2、新建一个source分支，新建md文件初始化source分支 3、本地拉取source分支代码 然后将你本地的之前博客项目的文件都复制过去（除了.deploy_git,.github,.git等文件，themes下的主题中.github也删掉） 并新建一个.gitignore文件，内容如下12345678910.DS_Store.idea/Thumbs.dbdb.json*.lognode_modules/public/.deploy*/_multiconfig.ymlpackage-lock.json 4、把代码推送到source分支 5、电脑配置git ssh公钥自行百度 6、安装部署插件npm install hexo-deployer-git --save _config.yml文件中配置部署:123456# Deployment 部署配置## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git #仓库类型 repo: git@github.com:AAAJQHAAA/aaajqhaaa.github.io.git #仓库地址 branch: main #主分支 7、打包部署，编译后的文件会推送到主分支 清除：npm run clean 打包：npm run build 部署：npm run deploy 8、github配置访问 settings-pages-Source-选择部署主分支 然后就可以访问了账号名.github.io","categories":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://aaajqhaaa.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://aaajqhaaa.github.io/categories/%E5%85%B6%E4%BB%96/"}]}]}